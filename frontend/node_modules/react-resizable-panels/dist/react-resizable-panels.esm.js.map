{"mappings":"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","sources":["packages/react-resizable-panels/src/index.ts","packages/react-resizable-panels/src/Panel.ts","packages/react-resizable-panels/src/hooks/useIsomorphicEffect.ts","packages/react-resizable-panels/src/env-conditions/browser.ts","packages/react-resizable-panels/src/vendor/react.ts","packages/react-resizable-panels/src/hooks/useUniqueId.ts","packages/react-resizable-panels/src/PanelContexts.ts","packages/react-resizable-panels/src/PanelGroup.ts","packages/react-resizable-panels/src/env-conditions/development.ts","packages/react-resizable-panels/src/hooks/useWindowSplitterBehavior.ts","packages/react-resizable-panels/src/constants.ts","packages/react-resizable-panels/src/utils/group.ts","packages/react-resizable-panels/src/utils/assert.ts","packages/react-resizable-panels/src/utils/arrays.ts","packages/react-resizable-panels/src/utils/coordinates.ts","packages/react-resizable-panels/src/utils/cursor.ts","packages/react-resizable-panels/src/utils/debounce.ts","packages/react-resizable-panels/src/utils/serialization.ts","packages/react-resizable-panels/src/PanelResizeHandle.ts"],"sourcesContent":["import { Panel } from \"./Panel\";\nimport { PanelGroup } from \"./PanelGroup\";\nimport { PanelResizeHandle } from \"./PanelResizeHandle\";\n\nimport type { ImperativePanelHandle, PanelProps } from \"./Panel\";\nimport type { ImperativePanelGroupHandle, PanelGroupProps } from \"./PanelGroup\";\nimport type { PanelResizeHandleProps } from \"./PanelResizeHandle\";\nimport { getAvailableGroupSizePixels } from \"./utils/group\";\nimport type {\n  PanelGroupOnLayout,\n  PanelGroupStorage,\n  PanelOnCollapse,\n  PanelOnResize,\n  PanelResizeHandleOnDragging,\n  Units,\n} from \"./types\";\n\nexport {\n  // TypeScript types\n  ImperativePanelGroupHandle,\n  ImperativePanelHandle,\n  PanelOnCollapse,\n  PanelOnResize,\n  PanelGroupOnLayout,\n  PanelGroupProps,\n  PanelGroupStorage,\n  PanelProps,\n  PanelResizeHandleOnDragging,\n  PanelResizeHandleProps,\n  Units,\n\n  // React components\n  Panel,\n  PanelGroup,\n  PanelResizeHandle,\n\n  // Utility methods\n  getAvailableGroupSizePixels,\n};\n","import useIsomorphicLayoutEffect from \"./hooks/useIsomorphicEffect\";\nimport useUniqueId from \"./hooks/useUniqueId\";\nimport {\n  createElement,\n  CSSProperties,\n  ElementType,\n  ForwardedRef,\n  forwardRef,\n  ReactNode,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n} from \"./vendor/react\";\n\nimport { PanelGroupContext } from \"./PanelContexts\";\nimport {\n  PanelCallbackRef,\n  PanelData,\n  PanelOnCollapse,\n  PanelOnResize,\n  Units,\n} from \"./types\";\nimport { getAvailableGroupSizePixels } from \"./utils/group\";\n\nexport type PanelProps = {\n  children?: ReactNode;\n  className?: string;\n  collapsedSize?: number;\n  collapsible?: boolean;\n  defaultSize?: number | null;\n  id?: string | null;\n  maxSize?: number | null;\n  minSize?: number;\n  onCollapse?: PanelOnCollapse | null;\n  onResize?: PanelOnResize | null;\n  order?: number | null;\n  style?: CSSProperties;\n  tagName?: ElementType;\n};\n\nexport type ImperativePanelHandle = {\n  collapse: () => void;\n  expand: () => void;\n  getCollapsed(): boolean;\n  getId(): string;\n  getSize(units?: Units): number;\n  resize: (percentage: number, units?: Units) => void;\n};\n\nfunction PanelWithForwardedRef({\n  children = null,\n  className: classNameFromProps = \"\",\n  collapsedSize = 0,\n  collapsible = false,\n  defaultSize = null,\n  forwardedRef,\n  id: idFromProps = null,\n  maxSize = null,\n  minSize,\n  onCollapse = null,\n  onResize = null,\n  order = null,\n  style: styleFromProps = {},\n  tagName: Type = \"div\",\n}: PanelProps & {\n  forwardedRef: ForwardedRef<ImperativePanelHandle>;\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(\n      `Panel components must be rendered within a PanelGroup container`\n    );\n  }\n\n  const panelId = useUniqueId(idFromProps);\n\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    registerPanel,\n    resizePanel,\n    units,\n    unregisterPanel,\n  } = context;\n\n  if (minSize == null) {\n    if (units === \"percentages\") {\n      // Mimics legacy default value for percentage based panel groups\n      minSize = 10;\n    } else {\n      // There is no meaningful minimum pixel default we can provide\n      minSize = 0;\n    }\n  }\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef<{\n    onCollapse: PanelOnCollapse | null;\n    onResize: PanelOnResize | null;\n  }>({ onCollapse, onResize });\n  useEffect(() => {\n    callbacksRef.current.onCollapse = onCollapse;\n    callbacksRef.current.onResize = onResize;\n  });\n\n  const style = getPanelStyle(panelId, defaultSize);\n\n  const committedValuesRef = useRef<{\n    size: number;\n  }>({\n    size: parseSizeFromStyle(style),\n  });\n\n  const panelDataRef = useRef<{\n    callbacksRef: PanelCallbackRef;\n    collapsedSize: number;\n    collapsible: boolean;\n    defaultSize: number | null;\n    id: string;\n    idWasAutoGenerated: boolean;\n    maxSize: number | null;\n    minSize: number;\n    order: number | null;\n  }>({\n    callbacksRef,\n    collapsedSize,\n    collapsible,\n    defaultSize,\n    id: panelId,\n    idWasAutoGenerated: idFromProps == null,\n    maxSize,\n    minSize,\n    order,\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.size = parseSizeFromStyle(style);\n\n    panelDataRef.current.callbacksRef = callbacksRef;\n    panelDataRef.current.collapsedSize = collapsedSize;\n    panelDataRef.current.collapsible = collapsible;\n    panelDataRef.current.defaultSize = defaultSize;\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idWasAutoGenerated = idFromProps == null;\n    panelDataRef.current.maxSize = maxSize;\n    panelDataRef.current.minSize = minSize as number;\n    panelDataRef.current.order = order;\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    registerPanel(panelId, panelDataRef as PanelData);\n\n    return () => {\n      unregisterPanel(panelId);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n\n  useImperativeHandle(\n    forwardedRef,\n    () => ({\n      collapse: () => collapsePanel(panelId),\n      expand: () => expandPanel(panelId),\n      getCollapsed() {\n        return committedValuesRef.current.size === 0;\n      },\n      getId() {\n        return panelId;\n      },\n      getSize(units) {\n        return getPanelSize(panelId, units);\n      },\n      resize: (percentage: number, units) =>\n        resizePanel(panelId, percentage, units),\n    }),\n    [collapsePanel, expandPanel, getPanelSize, panelId, resizePanel]\n  );\n\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-panel\": \"\",\n    \"data-panel-collapsible\": collapsible || undefined,\n    \"data-panel-id\": panelId,\n    \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1),\n    id: `data-panel-id-${panelId}`,\n    style: {\n      ...style,\n      ...styleFromProps,\n    },\n  });\n}\n\nexport const Panel = forwardRef<ImperativePanelHandle, PanelProps>(\n  (props: PanelProps, ref: ForwardedRef<ImperativePanelHandle>) =>\n    createElement(PanelWithForwardedRef, { ...props, forwardedRef: ref })\n);\n\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\n// HACK\nfunction parseSizeFromStyle(style: CSSProperties): number {\n  const { flexGrow } = style;\n  if (typeof flexGrow === \"string\") {\n    return parseFloat(flexGrow);\n  } else {\n    return flexGrow as number;\n  }\n}\n","import { isBrowser } from \"#is-browser\";\nimport { useLayoutEffect } from \"../vendor/react\";\n\nconst useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : () => {};\n\nexport default useIsomorphicLayoutEffect;\n","export const isBrowser = true;\n","// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n// and limitations with ParcelJS parsing of the useId workaround (used below).\n// For the time being, all react-resizable-panels must import \"react\" with the \"* as React\" syntax.\n// To avoid mistakes, we use the ESLint \"no-restricted-imports\" to prevent \"react\" imports except in this file.\n// See https://github.com/bvaughn/react-resizable-panels/issues/118\n\n// eslint-disable-next-line no-restricted-imports\nimport * as React from \"react\";\n\n// eslint-disable-next-line no-restricted-imports\nimport type {\n  CSSProperties,\n  ElementType,\n  ForwardedRef,\n  MouseEvent,\n  ReactNode,\n  RefObject,\n  TouchEvent,\n} from \"react\";\n\nconst {\n  createElement,\n  createContext,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} = React;\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = (React as any)[\"useId\".toString()] as () => string;\n\nexport {\n  createElement,\n  createContext,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useId,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n};\n\nexport type {\n  CSSProperties,\n  ElementType,\n  ForwardedRef,\n  MouseEvent,\n  ReactNode,\n  RefObject,\n  TouchEvent,\n};\n","import { useId, useRef } from \"../vendor/react\";\n\nconst wrappedUseId: () => string | null =\n  typeof useId === \"function\" ? useId : (): null => null;\n\nlet counter = 0;\n\nexport default function useUniqueId(\n  idFromParams: string | null = null\n): string {\n  const idFromUseId = wrappedUseId();\n\n  const idRef = useRef<string | null>(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n\n  return idRef.current;\n}\n","import { CSSProperties, createContext } from \"./vendor/react\";\n\nimport { PanelData, ResizeEvent, ResizeHandler, Units } from \"./types\";\n\nexport const PanelGroupContext = createContext<{\n  activeHandleId: string | null;\n  collapsePanel: (id: string) => void;\n  direction: \"horizontal\" | \"vertical\";\n  expandPanel: (id: string) => void;\n  getPanelSize: (id: string, units?: Units) => number;\n  getPanelStyle: (id: string, defaultSize: number | null) => CSSProperties;\n  groupId: string;\n  registerPanel: (id: string, panel: PanelData) => void;\n  registerResizeHandle: (id: string) => ResizeHandler;\n  resizePanel: (id: string, percentage: number, units?: Units) => void;\n  startDragging: (id: string, event: ResizeEvent) => void;\n  stopDragging: () => void;\n  unregisterPanel: (id: string) => void;\n  units: Units;\n} | null>(null);\n\nPanelGroupContext.displayName = \"PanelGroupContext\";\n","import { isBrowser } from \"#is-browser\";\nimport { isDevelopment } from \"#is-development\";\nimport {\n  createElement,\n  CSSProperties,\n  ElementType,\n  ForwardedRef,\n  forwardRef,\n  ReactNode,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n} from \"./vendor/react\";\n\nimport useIsomorphicLayoutEffect from \"./hooks/useIsomorphicEffect\";\nimport useUniqueId from \"./hooks/useUniqueId\";\nimport { useWindowSplitterPanelGroupBehavior } from \"./hooks/useWindowSplitterBehavior\";\nimport { PanelGroupContext } from \"./PanelContexts\";\nimport {\n  Direction,\n  PanelData,\n  PanelGroupOnLayout,\n  PanelGroupStorage,\n  ResizeEvent,\n  Units,\n} from \"./types\";\nimport { areEqual } from \"./utils/arrays\";\nimport {\n  getDragOffset,\n  getMovement,\n  isMouseEvent,\n  isTouchEvent,\n} from \"./utils/coordinates\";\nimport { resetGlobalCursorStyle, setGlobalCursorStyle } from \"./utils/cursor\";\nimport debounce from \"./utils/debounce\";\nimport {\n  adjustByDelta,\n  calculateDefaultLayout,\n  callPanelCallbacks,\n  getAvailableGroupSizePixels,\n  getBeforeAndAfterIds,\n  getFlexGrow,\n  getPanelGroup,\n  getResizeHandle,\n  getResizeHandlePanelIds,\n  panelsMapToSortedArray,\n  validatePanelGroupLayout,\n  validatePanelProps,\n} from \"./utils/group\";\nimport { loadPanelLayout, savePanelGroupLayout } from \"./utils/serialization\";\n\nconst debounceMap: {\n  [key: string]: (\n    autoSaveId: string,\n    panels: PanelData[],\n    sizes: number[],\n    storage: PanelGroupStorage\n  ) => void;\n} = {};\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject: PanelGroupStorage) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = (name: string) => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name: string, value: string) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\n\nconst defaultStorage: PanelGroupStorage = {\n  getItem: (name: string) => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name: string, value: string) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  },\n};\n\nexport type CommittedValues = {\n  direction: Direction;\n  id: string;\n  panels: Map<string, PanelData>;\n  sizes: number[];\n  units: Units;\n};\n\nexport type PanelDataMap = Map<string, PanelData>;\n\n// Initial drag state serves a few purposes:\n// * dragOffset:\n//   Resize is calculated by the distance between the current pointer event and the resize handle being \"dragged\"\n//   This value accounts for the initial offset when the touch/click starts, so the handle doesn't appear to \"jump\"\n// * dragHandleRect, sizes:\n//   When resizing is done via mouse/touch event– some initial state is stored\n//   so that any panels that contract will also expand if drag direction is reversed.\nexport type InitialDragState = {\n  dragHandleRect: DOMRect;\n  dragOffset: number;\n  sizes: number[];\n};\n\nexport type PanelGroupProps = {\n  autoSaveId?: string;\n  children?: ReactNode;\n  className?: string;\n  direction: Direction;\n  disablePointerEventsDuringResize?: boolean;\n  id?: string | null;\n  onLayout?: PanelGroupOnLayout;\n  storage?: PanelGroupStorage;\n  style?: CSSProperties;\n  tagName?: ElementType;\n  units?: Units;\n};\n\nexport type ImperativePanelGroupHandle = {\n  getId: () => string;\n  getLayout: (units?: Units) => number[];\n  setLayout: (panelSizes: number[], units?: Units) => void;\n};\n\nfunction PanelGroupWithForwardedRef({\n  autoSaveId,\n  children = null,\n  className: classNameFromProps = \"\",\n  direction,\n  disablePointerEventsDuringResize = false,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout,\n  storage = defaultStorage,\n  style: styleFromProps = {},\n  tagName: Type = \"div\",\n  units = \"percentages\",\n}: PanelGroupProps & {\n  forwardedRef: ForwardedRef<ImperativePanelGroupHandle>;\n}) {\n  const groupId = useUniqueId(idFromProps);\n\n  const [activeHandleId, setActiveHandleId] = useState<string | null>(null);\n  const [panels, setPanels] = useState<PanelDataMap>(new Map());\n\n  // When resizing is done via mouse/touch event–\n  // We store the initial Panel sizes in this ref, and apply move deltas to them instead of to the current sizes.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const initialDragStateRef = useRef<InitialDragState | null>(null);\n\n  const devWarningsRef = useRef<{\n    didLogDefaultSizeWarning: boolean;\n    didLogIdAndOrderWarning: boolean;\n    didLogInvalidLayoutWarning: boolean;\n    prevPanelIds: string[];\n  }>({\n    didLogDefaultSizeWarning: false,\n    didLogIdAndOrderWarning: false,\n    didLogInvalidLayoutWarning: false,\n    prevPanelIds: [],\n  });\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef<{\n    onLayout: PanelGroupOnLayout | undefined;\n  }>({ onLayout });\n  useEffect(() => {\n    callbacksRef.current.onLayout = onLayout;\n  });\n\n  const panelIdToLastNotifiedSizeMapRef = useRef<Record<string, number>>({});\n\n  // 0-1 values representing the relative size of each panel.\n  const [sizes, setSizes] = useState<number[]>([]);\n\n  // Used to support imperative collapse/expand API.\n  const panelSizeBeforeCollapse = useRef<Map<string, number>>(new Map());\n\n  const prevDeltaRef = useRef<number>(0);\n\n  // Store committed values to avoid unnecessarily re-running memoization/effects functions.\n  const committedValuesRef = useRef<CommittedValues>({\n    direction,\n    id: groupId,\n    panels,\n    sizes,\n    units,\n  });\n\n  useImperativeHandle(\n    forwardedRef,\n    () => ({\n      getId: () => groupId,\n      getLayout: (unitsFromParams?: Units) => {\n        const { sizes, units: unitsFromProps } = committedValuesRef.current;\n\n        const units = unitsFromParams ?? unitsFromProps;\n        if (units === \"pixels\") {\n          const groupSizePixels = getAvailableGroupSizePixels(groupId);\n          return sizes.map((size) => (size / 100) * groupSizePixels);\n        } else {\n          return sizes;\n        }\n      },\n      setLayout: (sizes: number[], unitsFromParams?: Units) => {\n        const {\n          id: groupId,\n          panels,\n          sizes: prevSizes,\n          units,\n        } = committedValuesRef.current;\n\n        if ((unitsFromParams || units) === \"pixels\") {\n          const groupSizePixels = getAvailableGroupSizePixels(groupId);\n          sizes = sizes.map((size) => (size / groupSizePixels) * 100);\n        }\n\n        const panelIdToLastNotifiedSizeMap =\n          panelIdToLastNotifiedSizeMapRef.current;\n        const panelsArray = panelsMapToSortedArray(panels);\n\n        const nextSizes = validatePanelGroupLayout({\n          groupId,\n          panels,\n          nextSizes: sizes,\n          prevSizes,\n          units,\n        });\n        if (!areEqual(prevSizes, nextSizes)) {\n          setSizes(nextSizes);\n\n          callPanelCallbacks(\n            panelsArray,\n            nextSizes,\n            panelIdToLastNotifiedSizeMap\n          );\n        }\n      },\n    }),\n    [groupId]\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.panels = panels;\n    committedValuesRef.current.sizes = sizes;\n    committedValuesRef.current.units = units;\n  });\n\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    groupId,\n    panels,\n    setSizes,\n    sizes,\n    panelSizeBeforeCollapse,\n  });\n\n  // Notify external code when sizes have changed.\n  useEffect(() => {\n    const { onLayout } = callbacksRef.current!;\n    const { panels, sizes } = committedValuesRef.current;\n\n    // Don't commit layout until all panels have registered and re-rendered with their actual sizes.\n    if (sizes.length > 0) {\n      if (onLayout) {\n        onLayout(sizes);\n      }\n\n      const panelIdToLastNotifiedSizeMap =\n        panelIdToLastNotifiedSizeMapRef.current;\n\n      // When possible, we notify before the next render so that rendering work can be batched together.\n      // Some cases are difficult to detect though,\n      // for example– panels that are conditionally rendered can affect the size of neighboring panels.\n      // In this case, the best we can do is notify on commit.\n      // The callPanelCallbacks() uses its own memoization to avoid notifying panels twice in these cases.\n      const panelsArray = panelsMapToSortedArray(panels);\n      callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, [sizes]);\n\n  // Once all panels have registered themselves,\n  // Compute the initial sizes based on default weights.\n  // This assumes that panels register during initial mount (no conditional rendering)!\n  useIsomorphicLayoutEffect(() => {\n    const { id: groupId, sizes, units } = committedValuesRef.current;\n    if (sizes.length === panels.size) {\n      // Only compute (or restore) default sizes once per panel configuration.\n      return;\n    }\n\n    // If this panel has been configured to persist sizing information,\n    // default size should be restored from local storage if possible.\n    let defaultSizes: number[] | null = null;\n    if (autoSaveId) {\n      const panelsArray = panelsMapToSortedArray(panels);\n      defaultSizes = loadPanelLayout(autoSaveId, panelsArray, storage);\n    }\n\n    if (defaultSizes != null) {\n      // Validate saved sizes in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const validatedSizes = validatePanelGroupLayout({\n        groupId,\n        panels,\n        nextSizes: defaultSizes,\n        prevSizes: defaultSizes,\n        units,\n      });\n\n      setSizes(validatedSizes);\n    } else {\n      const sizes = calculateDefaultLayout({\n        groupId,\n        panels,\n        units,\n      });\n\n      setSizes(sizes);\n    }\n  }, [autoSaveId, panels, storage]);\n\n  useEffect(() => {\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (sizes.length === 0 || sizes.length !== panels.size) {\n        return;\n      }\n\n      const panelsArray = panelsMapToSortedArray(panels);\n\n      // Limit the frequency of localStorage updates.\n      if (!debounceMap[autoSaveId]) {\n        debounceMap[autoSaveId] = debounce(savePanelGroupLayout, 100);\n      }\n      debounceMap[autoSaveId](autoSaveId, panelsArray, sizes, storage);\n    }\n\n    if (isDevelopment) {\n      const { didLogIdAndOrderWarning, prevPanelIds } = devWarningsRef.current;\n      if (!didLogIdAndOrderWarning) {\n        const { panels } = committedValuesRef.current;\n\n        const panelIds = Array.from(panels.keys());\n\n        devWarningsRef.current.prevPanelIds = panelIds;\n\n        const panelsHaveChanged =\n          prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n        if (panelsHaveChanged) {\n          if (\n            Array.from(panels.values()).find(\n              (panel) =>\n                panel.current.idWasAutoGenerated || panel.current.order == null\n            )\n          ) {\n            devWarningsRef.current.didLogIdAndOrderWarning = true;\n\n            console.warn(\n              `WARNING: Panel id and order props recommended when panels are dynamically rendered`\n            );\n          }\n        }\n      }\n    }\n  }, [autoSaveId, panels, sizes, storage]);\n\n  useIsomorphicLayoutEffect(() => {\n    // Pixel panel constraints need to be reassessed after a group resize\n    // We can avoid the ResizeObserver overhead for relative layouts\n    if (units === \"pixels\") {\n      const resizeObserver = new ResizeObserver(() => {\n        const { panels, sizes: prevSizes } = committedValuesRef.current;\n\n        const nextSizes = validatePanelGroupLayout({\n          groupId,\n          panels,\n          nextSizes: prevSizes,\n          prevSizes,\n          units,\n        });\n        if (!areEqual(prevSizes, nextSizes)) {\n          setSizes(nextSizes);\n        }\n      });\n\n      resizeObserver.observe(getPanelGroup(groupId)!);\n\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n  }, [groupId, units]);\n\n  const getPanelSize = useCallback(\n    (id: string, unitsFromParams?: Units) => {\n      const { panels, units: unitsFromProps } = committedValuesRef.current;\n\n      const panelsArray = panelsMapToSortedArray(panels);\n\n      const index = panelsArray.findIndex((panel) => panel.current.id === id);\n      const size = sizes[index];\n\n      const units = unitsFromParams ?? unitsFromProps;\n      if (units === \"pixels\") {\n        const groupSizePixels = getAvailableGroupSizePixels(groupId);\n        return (size / 100) * groupSizePixels;\n      } else {\n        return size;\n      }\n    },\n    [groupId, sizes]\n  );\n\n  const getPanelStyle = useCallback(\n    (id: string, defaultSize: number | null): CSSProperties => {\n      const { panels } = committedValuesRef.current;\n\n      // Before mounting, Panels will not yet have registered themselves.\n      // This includes server rendering.\n      // At this point the best we can do is render everything with the same size.\n      if (panels.size === 0) {\n        if (isDevelopment) {\n          if (!devWarningsRef.current.didLogDefaultSizeWarning) {\n            if (!isBrowser && defaultSize == null) {\n              devWarningsRef.current.didLogDefaultSizeWarning = true;\n              console.warn(\n                `WARNING: Panel defaultSize prop recommended to avoid layout shift after server rendering`\n              );\n            }\n          }\n        }\n\n        return {\n          flexBasis: 0,\n          flexGrow: defaultSize != null ? defaultSize : undefined,\n          flexShrink: 1,\n\n          // Without this, Panel sizes may be unintentionally overridden by their content.\n          overflow: \"hidden\",\n        };\n      }\n\n      const flexGrow = getFlexGrow(panels, id, sizes);\n\n      return {\n        flexBasis: 0,\n        flexGrow,\n        flexShrink: 1,\n\n        // Without this, Panel sizes may be unintentionally overridden by their content.\n        overflow: \"hidden\",\n\n        // Disable pointer events inside of a panel during resize.\n        // This avoid edge cases like nested iframes.\n        pointerEvents:\n          disablePointerEventsDuringResize && activeHandleId !== null\n            ? \"none\"\n            : undefined,\n      };\n    },\n    [activeHandleId, disablePointerEventsDuringResize, sizes]\n  );\n\n  const registerPanel = useCallback((id: string, panelRef: PanelData) => {\n    const { units } = committedValuesRef.current;\n\n    validatePanelProps(units, panelRef);\n\n    setPanels((prevPanels) => {\n      if (prevPanels.has(id)) {\n        return prevPanels;\n      }\n\n      const nextPanels = new Map(prevPanels);\n      nextPanels.set(id, panelRef);\n\n      return nextPanels;\n    });\n  }, []);\n\n  const registerResizeHandle = useCallback(\n    (handleId: string) => {\n      const resizeHandler = (event: ResizeEvent) => {\n        event.preventDefault();\n\n        const {\n          direction,\n          panels,\n          sizes: prevSizes,\n        } = committedValuesRef.current;\n\n        const panelsArray = panelsMapToSortedArray(panels);\n\n        const [idBefore, idAfter] = getResizeHandlePanelIds(\n          groupId,\n          handleId,\n          panelsArray\n        );\n        if (idBefore == null || idAfter == null) {\n          return;\n        }\n\n        let movement = getMovement(\n          event,\n          groupId,\n          handleId,\n          panelsArray,\n          direction,\n          prevSizes,\n          initialDragStateRef.current\n        );\n        if (movement === 0) {\n          return;\n        }\n\n        const groupElement = getPanelGroup(groupId)!;\n        const rect = groupElement.getBoundingClientRect();\n        const isHorizontal = direction === \"horizontal\";\n\n        // Support RTL layouts\n        if (document.dir === \"rtl\" && isHorizontal) {\n          movement = -movement;\n        }\n\n        const size = isHorizontal ? rect.width : rect.height;\n        const delta = (movement / size) * 100;\n\n        // If a validateLayout method has been provided\n        // it's important to use it before updating the mouse cursor\n        const nextSizes = adjustByDelta(\n          event,\n          committedValuesRef.current,\n          idBefore,\n          idAfter,\n          delta,\n          prevSizes,\n          panelSizeBeforeCollapse.current,\n          initialDragStateRef.current\n        );\n\n        const sizesChanged = !areEqual(prevSizes, nextSizes);\n\n        // Don't update cursor for resizes triggered by keyboard interactions.\n        if (isMouseEvent(event) || isTouchEvent(event)) {\n          // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n          // In this case, Panel sizes might not change–\n          // but updating cursor in this scenario would cause a flicker.\n          if (prevDeltaRef.current != delta) {\n            if (!sizesChanged) {\n              // If the pointer has moved too far to resize the panel any further,\n              // update the cursor style for a visual clue.\n              // This mimics VS Code behavior.\n\n              if (isHorizontal) {\n                setGlobalCursorStyle(\n                  movement < 0 ? \"horizontal-min\" : \"horizontal-max\"\n                );\n              } else {\n                setGlobalCursorStyle(\n                  movement < 0 ? \"vertical-min\" : \"vertical-max\"\n                );\n              }\n            } else {\n              // Reset the cursor style to the the normal resize cursor.\n              setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n            }\n          }\n        }\n\n        if (sizesChanged) {\n          const panelIdToLastNotifiedSizeMap =\n            panelIdToLastNotifiedSizeMapRef.current;\n\n          // It's okay to bypass in this case because we already validated above\n          setSizes(nextSizes);\n\n          // If resize change handlers have been declared, this is the time to call them.\n          // Trigger user callbacks after updating state, so that user code can override the sizes.\n          callPanelCallbacks(\n            panelsArray,\n            nextSizes,\n            panelIdToLastNotifiedSizeMap\n          );\n        }\n\n        prevDeltaRef.current = delta;\n      };\n\n      return resizeHandler;\n    },\n    [groupId]\n  );\n\n  const unregisterPanel = useCallback((id: string) => {\n    setPanels((prevPanels) => {\n      if (!prevPanels.has(id)) {\n        return prevPanels;\n      }\n\n      const nextPanels = new Map(prevPanels);\n      nextPanels.delete(id);\n\n      return nextPanels;\n    });\n  }, []);\n\n  const collapsePanel = useCallback((id: string) => {\n    const { panels, sizes: prevSizes } = committedValuesRef.current;\n\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n\n    const { collapsedSize, collapsible } = panel.current;\n    if (!collapsible) {\n      return;\n    }\n\n    const panelsArray = panelsMapToSortedArray(panels);\n\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n\n    const currentSize = prevSizes[index];\n    if (currentSize === collapsedSize) {\n      // Panel is already collapsed.\n      return;\n    }\n\n    panelSizeBeforeCollapse.current.set(id, currentSize);\n\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize : collapsedSize - currentSize;\n\n    const nextSizes = adjustByDelta(\n      null,\n      committedValuesRef.current,\n      idBefore,\n      idAfter,\n      delta,\n      prevSizes,\n      panelSizeBeforeCollapse.current,\n      null\n    );\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap =\n        panelIdToLastNotifiedSizeMapRef.current;\n\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n\n  const expandPanel = useCallback((id: string) => {\n    const { panels, sizes: prevSizes } = committedValuesRef.current;\n\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n\n    const { collapsedSize, minSize } = panel.current;\n\n    const sizeBeforeCollapse =\n      panelSizeBeforeCollapse.current.get(id) || minSize;\n    if (!sizeBeforeCollapse) {\n      return;\n    }\n\n    const panelsArray = panelsMapToSortedArray(panels);\n\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n\n    const currentSize = prevSizes[index];\n    if (currentSize !== collapsedSize) {\n      // Panel is already expanded.\n      return;\n    }\n\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel\n      ? collapsedSize - sizeBeforeCollapse\n      : sizeBeforeCollapse;\n\n    const nextSizes = adjustByDelta(\n      null,\n      committedValuesRef.current,\n      idBefore,\n      idAfter,\n      delta,\n      prevSizes,\n      panelSizeBeforeCollapse.current,\n      null\n    );\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap =\n        panelIdToLastNotifiedSizeMapRef.current;\n\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n\n  const resizePanel = useCallback(\n    (id: string, nextSize: number, unitsFromParams?: Units) => {\n      const {\n        id: groupId,\n        panels,\n        sizes: prevSizes,\n        units,\n      } = committedValuesRef.current;\n\n      if ((unitsFromParams || units) === \"pixels\") {\n        const groupSizePixels = getAvailableGroupSizePixels(groupId);\n        nextSize = (nextSize / groupSizePixels) * 100;\n      }\n\n      const panel = panels.get(id);\n      if (panel == null) {\n        return;\n      }\n\n      let { collapsedSize, collapsible, maxSize, minSize } = panel.current;\n\n      if (units === \"pixels\") {\n        const groupSizePixels = getAvailableGroupSizePixels(groupId);\n        minSize = (minSize / groupSizePixels) * 100;\n        if (maxSize != null) {\n          maxSize = (maxSize / groupSizePixels) * 100;\n        }\n      }\n\n      const panelsArray = panelsMapToSortedArray(panels);\n\n      const index = panelsArray.indexOf(panel);\n      if (index < 0) {\n        return;\n      }\n\n      const currentSize = prevSizes[index];\n      if (currentSize === nextSize) {\n        return;\n      }\n\n      if (collapsible && nextSize === collapsedSize) {\n        // This is a valid resize state.\n      } else {\n        const unsafeNextSize = nextSize;\n\n        nextSize = Math.min(\n          maxSize != null ? maxSize : 100,\n          Math.max(minSize, nextSize)\n        );\n\n        if (isDevelopment) {\n          if (unsafeNextSize !== nextSize) {\n            console.error(\n              `Invalid size (${unsafeNextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`\n            );\n          }\n        }\n      }\n\n      const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n      if (idBefore == null || idAfter == null) {\n        return;\n      }\n\n      const isLastPanel = index === panelsArray.length - 1;\n      const delta = isLastPanel\n        ? currentSize - nextSize\n        : nextSize - currentSize;\n\n      const nextSizes = adjustByDelta(\n        null,\n        committedValuesRef.current,\n        idBefore,\n        idAfter,\n        delta,\n        prevSizes,\n        panelSizeBeforeCollapse.current,\n        null\n      );\n      if (prevSizes !== nextSizes) {\n        const panelIdToLastNotifiedSizeMap =\n          panelIdToLastNotifiedSizeMapRef.current;\n\n        setSizes(nextSizes);\n\n        // If resize change handlers have been declared, this is the time to call them.\n        // Trigger user callbacks after updating state, so that user code can override the sizes.\n        callPanelCallbacks(\n          panelsArray,\n          nextSizes,\n          panelIdToLastNotifiedSizeMap\n        );\n      }\n    },\n    []\n  );\n\n  const context = useMemo(\n    () => ({\n      activeHandleId,\n      collapsePanel,\n      direction,\n      expandPanel,\n      getPanelSize,\n      getPanelStyle,\n      groupId,\n      registerPanel,\n      registerResizeHandle,\n      resizePanel,\n      startDragging: (id: string, event: ResizeEvent) => {\n        setActiveHandleId(id);\n\n        if (isMouseEvent(event) || isTouchEvent(event)) {\n          const handleElement = getResizeHandle(id)!;\n\n          initialDragStateRef.current = {\n            dragHandleRect: handleElement.getBoundingClientRect(),\n            dragOffset: getDragOffset(event, id, direction),\n            sizes: committedValuesRef.current.sizes,\n          };\n        }\n      },\n      stopDragging: () => {\n        resetGlobalCursorStyle();\n        setActiveHandleId(null);\n\n        initialDragStateRef.current = null;\n      },\n      units,\n      unregisterPanel,\n    }),\n    [\n      activeHandleId,\n      collapsePanel,\n      direction,\n      expandPanel,\n      getPanelSize,\n      getPanelStyle,\n      groupId,\n      registerPanel,\n      registerResizeHandle,\n      resizePanel,\n      units,\n      unregisterPanel,\n    ]\n  );\n\n  const style: CSSProperties = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\",\n  };\n\n  return createElement(PanelGroupContext.Provider, {\n    children: createElement(Type, {\n      children,\n      className: classNameFromProps,\n      \"data-panel-group\": \"\",\n      \"data-panel-group-direction\": direction,\n      \"data-panel-group-id\": groupId,\n      \"data-panel-group-units\": units,\n      style: { ...style, ...styleFromProps },\n    }),\n    value: context,\n  });\n}\n\nexport const PanelGroup = forwardRef<\n  ImperativePanelGroupHandle,\n  PanelGroupProps\n>((props: PanelGroupProps, ref: ForwardedRef<ImperativePanelGroupHandle>) =>\n  createElement(PanelGroupWithForwardedRef, { ...props, forwardedRef: ref })\n);\n\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\n","export const isDevelopment = true;\n","import { RefObject, useEffect } from \"../vendor/react\";\nimport { PRECISION } from \"../constants\";\n\nimport { CommittedValues, PanelDataMap } from \"../PanelGroup\";\nimport { ResizeHandler } from \"../types\";\nimport {\n  adjustByDelta,\n  getPanel,\n  getPanelGroup,\n  getResizeHandle,\n  getResizeHandleIndex,\n  getResizeHandlePanelIds,\n  getResizeHandles,\n  getResizeHandlesForGroup,\n  getFlexGrow,\n  panelsMapToSortedArray,\n} from \"../utils/group\";\nimport { assert } from \"../utils/assert\";\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nexport function useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  groupId,\n  panels,\n  setSizes,\n  sizes,\n  panelSizeBeforeCollapse,\n}: {\n  committedValuesRef: RefObject<CommittedValues>;\n  groupId: string;\n  panels: PanelDataMap;\n  setSizes: (sizes: number[]) => void;\n  sizes: number[];\n  panelSizeBeforeCollapse: RefObject<Map<string, number>>;\n}): void {\n  useEffect(() => {\n    const { direction, panels } = committedValuesRef.current!;\n\n    const groupElement = getPanelGroup(groupId);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n\n    const { height, width } = groupElement.getBoundingClientRect();\n\n    const handles = getResizeHandlesForGroup(groupId);\n    const cleanupFunctions = handles.map((handle) => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\")!;\n      const panelsArray = panelsMapToSortedArray(panels);\n\n      const [idBefore, idAfter] = getResizeHandlePanelIds(\n        groupId,\n        handleId,\n        panelsArray\n      );\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n\n      let currentMinSize = 0;\n      let currentMaxSize = 100;\n      let totalMinSize = 0;\n      let totalMaxSize = 0;\n\n      // A panel's effective min/max sizes also need to account for other panel's sizes.\n      panelsArray.forEach((panelData) => {\n        const { id, maxSize, minSize } = panelData.current;\n        if (id === idBefore) {\n          currentMinSize = minSize;\n          currentMaxSize = maxSize != null ? maxSize : 100;\n        } else {\n          totalMinSize += minSize;\n          totalMaxSize += maxSize != null ? maxSize : 100;\n        }\n      });\n\n      const ariaValueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n      const ariaValueMin = Math.max(\n        currentMinSize,\n        (panelsArray.length - 1) * 100 - totalMaxSize\n      );\n\n      const flexGrow = getFlexGrow(panels, idBefore, sizes);\n\n      handle.setAttribute(\"aria-valuemax\", \"\" + Math.round(ariaValueMax));\n      handle.setAttribute(\"aria-valuemin\", \"\" + Math.round(ariaValueMin));\n      handle.setAttribute(\"aria-valuenow\", \"\" + Math.round(parseInt(flexGrow)));\n\n      const onKeyDown = (event: KeyboardEvent) => {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        switch (event.key) {\n          case \"Enter\": {\n            event.preventDefault();\n\n            const index = panelsArray.findIndex(\n              (panel) => panel.current.id === idBefore\n            );\n            if (index >= 0) {\n              const panelData = panelsArray[index];\n              const size = sizes[index];\n              if (size != null) {\n                let delta = 0;\n                if (\n                  size.toPrecision(PRECISION) <=\n                  panelData.current.minSize.toPrecision(PRECISION)\n                ) {\n                  delta = direction === \"horizontal\" ? width : height;\n                } else {\n                  delta = -(direction === \"horizontal\" ? width : height);\n                }\n\n                const nextSizes = adjustByDelta(\n                  event,\n                  committedValuesRef.current!,\n                  idBefore,\n                  idAfter,\n                  delta,\n                  sizes,\n                  panelSizeBeforeCollapse.current!,\n                  null\n                );\n                if (sizes !== nextSizes) {\n                  setSizes(nextSizes);\n                }\n              }\n            }\n            break;\n          }\n        }\n      };\n\n      handle.addEventListener(\"keydown\", onKeyDown);\n\n      const panelBefore = getPanel(idBefore);\n      if (panelBefore != null) {\n        handle.setAttribute(\"aria-controls\", panelBefore.id);\n      }\n\n      return () => {\n        handle.removeAttribute(\"aria-valuemax\");\n        handle.removeAttribute(\"aria-valuemin\");\n        handle.removeAttribute(\"aria-valuenow\");\n\n        handle.removeEventListener(\"keydown\", onKeyDown);\n\n        if (panelBefore != null) {\n          handle.removeAttribute(\"aria-controls\");\n        }\n      };\n    });\n\n    return () => {\n      cleanupFunctions.forEach((cleanupFunction) => cleanupFunction());\n    };\n  }, [\n    committedValuesRef,\n    groupId,\n    panels,\n    panelSizeBeforeCollapse,\n    setSizes,\n    sizes,\n  ]);\n}\n\nexport function useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n}: {\n  disabled: boolean;\n  handleId: string;\n  resizeHandler: ResizeHandler | null;\n}): void {\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n\n    const handleElement = getResizeHandle(handleId);\n    if (handleElement == null) {\n      return;\n    }\n\n    const onKeyDown = (event: KeyboardEvent) => {\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\": {\n          event.preventDefault();\n\n          resizeHandler(event);\n          break;\n        }\n        case \"F6\": {\n          event.preventDefault();\n\n          const handles = getResizeHandles();\n          const index = getResizeHandleIndex(handleId);\n\n          assert(index !== null);\n\n          const nextIndex = event.shiftKey\n            ? index > 0\n              ? index - 1\n              : handles.length - 1\n            : index + 1 < handles.length\n            ? index + 1\n            : 0;\n\n          const nextHandle = handles[nextIndex] as HTMLDivElement;\n          nextHandle.focus();\n\n          break;\n        }\n      }\n    };\n\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [disabled, handleId, resizeHandler]);\n}\n","export const PRECISION = 10;\n","import { isDevelopment } from \"#is-development\";\nimport { CommittedValues, InitialDragState } from \"../PanelGroup\";\nimport { PRECISION } from \"../constants\";\nimport { PanelData, ResizeEvent, Units } from \"../types\";\n\nexport function adjustByDelta(\n  event: ResizeEvent | null,\n  committedValues: CommittedValues,\n  idBefore: string,\n  idAfter: string,\n  deltaPixels: number,\n  prevSizes: number[],\n  panelSizeBeforeCollapse: Map<string, number>,\n  initialDragState: InitialDragState | null\n): number[] {\n  const { id: groupId, panels, units } = committedValues;\n\n  const groupSizePixels =\n    units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n\n  const { sizes: initialSizes } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n\n  const panelsArray = panelsMapToSortedArray(panels);\n\n  const nextSizes = baseSizes.concat();\n\n  let deltaApplied = 0;\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel immediately after the resizer should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel immediately before the resizer should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resizer.\n\n  // Max-bounds check the panel being expanded first.\n  {\n    const pivotId = deltaPixels < 0 ? idAfter : idBefore;\n    const index = panelsArray.findIndex(\n      (panel) => panel.current.id === pivotId\n    );\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n\n    const nextSize = safeResizePanel(\n      units,\n      groupSizePixels,\n      panel,\n      baseSize,\n      baseSize + Math.abs(deltaPixels),\n      event\n    );\n    if (baseSize === nextSize) {\n      // If there's no room for the pivot panel to grow, we can ignore this drag update.\n      return baseSizes;\n    } else {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(pivotId, baseSize);\n      }\n\n      deltaPixels = deltaPixels < 0 ? baseSize - nextSize : nextSize - baseSize;\n    }\n  }\n\n  let pivotId = deltaPixels < 0 ? idBefore : idAfter;\n  let index = panelsArray.findIndex((panel) => panel.current.id === pivotId);\n  while (true) {\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n\n    const deltaRemaining = Math.abs(deltaPixels) - Math.abs(deltaApplied);\n\n    const nextSize = safeResizePanel(\n      units,\n      groupSizePixels,\n      panel,\n      baseSize,\n      baseSize - deltaRemaining,\n      event\n    );\n    if (baseSize !== nextSize) {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(panel.current.id, baseSize);\n      }\n\n      deltaApplied += baseSize - nextSize;\n\n      nextSizes[index] = nextSize;\n\n      if (\n        deltaApplied\n          .toPrecision(PRECISION)\n          .localeCompare(\n            Math.abs(deltaPixels).toPrecision(PRECISION),\n            undefined,\n            {\n              numeric: true,\n            }\n          ) >= 0\n      ) {\n        break;\n      }\n    }\n\n    if (deltaPixels < 0) {\n      if (--index < 0) {\n        break;\n      }\n    } else {\n      if (++index >= panelsArray.length) {\n        break;\n      }\n    }\n  }\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore the \"mousemove\" event.\n  if (deltaApplied === 0) {\n    return baseSizes;\n  }\n\n  // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n  pivotId = deltaPixels < 0 ? idAfter : idBefore;\n  index = panelsArray.findIndex((panel) => panel.current.id === pivotId);\n  nextSizes[index] = baseSizes[index] + deltaApplied;\n\n  return nextSizes;\n}\n\nexport function callPanelCallbacks(\n  panelsArray: PanelData[],\n  sizes: number[],\n  panelIdToLastNotifiedSizeMap: Record<string, number>\n) {\n  sizes.forEach((size, index) => {\n    const panelRef = panelsArray[index];\n    if (!panelRef) {\n      // Handle initial mount (when panels are registered too late to be in the panels array)\n      // The subsequent render+effects will handle the resize notification\n      return;\n    }\n\n    const { callbacksRef, collapsedSize, collapsible, id } = panelRef.current;\n\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[id];\n    if (lastNotifiedSize !== size) {\n      panelIdToLastNotifiedSizeMap[id] = size;\n\n      const { onCollapse, onResize } = callbacksRef.current!;\n\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n\n      if (collapsible && onCollapse) {\n        if (\n          (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) &&\n          size !== collapsedSize\n        ) {\n          onCollapse(false);\n        } else if (\n          lastNotifiedSize !== collapsedSize &&\n          size === collapsedSize\n        ) {\n          onCollapse(true);\n        }\n      }\n    }\n  });\n}\n\nexport function calculateDefaultLayout({\n  groupId,\n  panels,\n  units,\n}: {\n  groupId: string;\n  panels: Map<string, PanelData>;\n  units: Units;\n}): number[] {\n  const groupSizePixels =\n    units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  const panelsArray = panelsMapToSortedArray(panels);\n  const sizes = Array<number>(panelsArray.length);\n\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Assigning default sizes requires a couple of passes:\n  // First, all panels with defaultSize should be set as-is\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    const { defaultSize } = panel.current;\n\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n\n      sizes[index] =\n        units === \"pixels\"\n          ? (defaultSize / groupSizePixels) * 100\n          : defaultSize;\n\n      remainingSize -= sizes[index];\n    }\n  }\n\n  // Remaining total size should be distributed evenly between panels\n  // This may require two passes, depending on min/max constraints\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    let { defaultSize, id, maxSize, minSize } = panel.current;\n    if (defaultSize != null) {\n      continue;\n    }\n\n    if (units === \"pixels\") {\n      minSize = (minSize / groupSizePixels) * 100;\n      if (maxSize != null) {\n        maxSize = (maxSize / groupSizePixels) * 100;\n      }\n    }\n\n    const remainingPanels = panelsArray.length - numPanelsWithSizes;\n    const size = Math.min(\n      maxSize != null ? maxSize : 100,\n      Math.max(minSize, remainingSize / remainingPanels)\n    );\n\n    sizes[index] = size;\n    numPanelsWithSizes++;\n    remainingSize -= size;\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (remainingSize !== 0) {\n    for (let index = 0; index < panelsArray.length; index++) {\n      const panel = panelsArray[index];\n      let { maxSize, minSize } = panel.current;\n\n      if (units === \"pixels\") {\n        minSize = (minSize / groupSizePixels) * 100;\n        if (maxSize != null) {\n          maxSize = (maxSize / groupSizePixels) * 100;\n        }\n      }\n\n      const size = Math.min(\n        maxSize != null ? maxSize : 100,\n        Math.max(minSize, sizes[index] + remainingSize)\n      );\n\n      if (size !== sizes[index]) {\n        remainingSize -= size - sizes[index];\n        sizes[index] = size;\n\n        // Fuzzy comparison to account for imprecise floating point math\n        if (Math.abs(remainingSize).toFixed(3) === \"0.000\") {\n          break;\n        }\n      }\n    }\n  }\n\n  // Finally, if there is still left-over size, log an error\n  if (Math.abs(remainingSize).toFixed(3) !== \"0.000\") {\n    if (isDevelopment) {\n      console.error(\n        `Invalid panel group configuration; default panel sizes should total 100% but was ${(\n          100 - remainingSize\n        ).toFixed(\n          1\n        )}%. This can cause the cursor to become misaligned while dragging.`\n      );\n    }\n  }\n\n  return sizes;\n}\n\nexport function getBeforeAndAfterIds(\n  id: string,\n  panelsArray: PanelData[]\n): [idBefore: string | null, idAFter: string | null] {\n  if (panelsArray.length < 2) {\n    return [null, null];\n  }\n\n  const index = panelsArray.findIndex((panel) => panel.current.id === id);\n  if (index < 0) {\n    return [null, null];\n  }\n\n  const isLastPanel = index === panelsArray.length - 1;\n  const idBefore = isLastPanel ? panelsArray[index - 1].current.id : id;\n  const idAfter = isLastPanel ? id : panelsArray[index + 1].current.id;\n\n  return [idBefore, idAfter];\n}\n\nexport function getAvailableGroupSizePixels(groupId: string): number {\n  const panelGroupElement = getPanelGroup(groupId);\n  if (panelGroupElement == null) {\n    return NaN;\n  }\n\n  const direction = panelGroupElement.getAttribute(\n    \"data-panel-group-direction\"\n  );\n  const resizeHandles = getResizeHandlesForGroup(groupId);\n  if (direction === \"horizontal\") {\n    return (\n      panelGroupElement.offsetWidth -\n      resizeHandles.reduce((accumulated, handle) => {\n        return accumulated + handle.offsetWidth;\n      }, 0)\n    );\n  } else {\n    return (\n      panelGroupElement.offsetHeight -\n      resizeHandles.reduce((accumulated, handle) => {\n        return accumulated + handle.offsetHeight;\n      }, 0)\n    );\n  }\n}\n\n// This method returns a number between 1 and 100 representing\n// the % of the group's overall space this panel should occupy.\nexport function getFlexGrow(\n  panels: Map<string, PanelData>,\n  id: string,\n  sizes: number[]\n): string {\n  if (panels.size === 1) {\n    return \"100\";\n  }\n\n  const panelsArray = panelsMapToSortedArray(panels);\n\n  const index = panelsArray.findIndex((panel) => panel.current.id === id);\n  const size = sizes[index];\n  if (size == null) {\n    return \"0\";\n  }\n\n  return size.toPrecision(PRECISION);\n}\n\nexport function getPanel(id: string): HTMLDivElement | null {\n  const element = document.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element as HTMLDivElement;\n  }\n  return null;\n}\n\nexport function getPanelGroup(id: string): HTMLDivElement | null {\n  const element = document.querySelector(`[data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element as HTMLDivElement;\n  }\n  return null;\n}\n\nexport function getResizeHandle(id: string): HTMLDivElement | null {\n  const element = document.querySelector(\n    `[data-panel-resize-handle-id=\"${id}\"]`\n  );\n  if (element) {\n    return element as HTMLDivElement;\n  }\n  return null;\n}\n\nexport function getResizeHandleIndex(id: string): number | null {\n  const handles = getResizeHandles();\n  const index = handles.findIndex(\n    (handle) => handle.getAttribute(\"data-panel-resize-handle-id\") === id\n  );\n  return index ?? null;\n}\n\nexport function getResizeHandles(): HTMLDivElement[] {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id]`));\n}\n\nexport function getResizeHandlesForGroup(groupId: string): HTMLDivElement[] {\n  return Array.from(\n    document.querySelectorAll(\n      `[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`\n    )\n  );\n}\n\nexport function getResizeHandlePanelIds(\n  groupId: string,\n  handleId: string,\n  panelsArray: PanelData[]\n): [idBefore: string | null, idAfter: string | null] {\n  const handle = getResizeHandle(handleId);\n  const handles = getResizeHandlesForGroup(groupId);\n  const index = handle ? handles.indexOf(handle) : -1;\n\n  const idBefore: string | null = panelsArray[index]?.current?.id ?? null;\n  const idAfter: string | null = panelsArray[index + 1]?.current?.id ?? null;\n\n  return [idBefore, idAfter];\n}\n\nexport function panelsMapToSortedArray(\n  panels: Map<string, PanelData>\n): PanelData[] {\n  return Array.from(panels.values()).sort((panelA, panelB) => {\n    const orderA = panelA.current.order;\n    const orderB = panelB.current.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\n\nexport function safeResizePanel(\n  units: Units,\n  groupSizePixels: number,\n  panel: PanelData,\n  prevSize: number,\n  nextSize: number,\n  event: ResizeEvent | null = null\n): number {\n  let { collapsedSize, collapsible, maxSize, minSize } = panel.current;\n\n  if (units === \"pixels\") {\n    collapsedSize = (collapsedSize / groupSizePixels) * 100;\n    if (maxSize != null) {\n      maxSize = (maxSize / groupSizePixels) * 100;\n    }\n    minSize = (minSize / groupSizePixels) * 100;\n  }\n\n  if (collapsible) {\n    if (prevSize > collapsedSize) {\n      // Mimic VS COde behavior; collapse a panel if it's smaller than half of its min-size\n      if (nextSize <= minSize / 2 + collapsedSize) {\n        return collapsedSize;\n      }\n    } else {\n      const isKeyboardEvent = event?.type?.startsWith(\"key\");\n      if (!isKeyboardEvent) {\n        // Keyboard events should expand a collapsed panel to the min size,\n        // but mouse events should wait until the panel has reached its min size\n        // to avoid a visual flickering when dragging between collapsed and min size.\n        if (nextSize < minSize) {\n          return collapsedSize;\n        }\n      }\n    }\n  }\n\n  return Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSize));\n}\n\nexport function validatePanelProps(units: Units, panelData: PanelData) {\n  const { collapsible, defaultSize, maxSize, minSize } = panelData.current;\n\n  // Basic props validation\n  if (minSize < 0 || (units === \"percentages\" && minSize > 100)) {\n    if (isDevelopment) {\n      console.error(`Invalid Panel minSize provided, ${minSize}`);\n    }\n\n    panelData.current.minSize = 0;\n  }\n\n  if (maxSize != null) {\n    if (maxSize < 0 || (units === \"percentages\" && maxSize > 100)) {\n      if (isDevelopment) {\n        console.error(`Invalid Panel maxSize provided, ${maxSize}`);\n      }\n\n      panelData.current.maxSize = null;\n    }\n  }\n\n  if (defaultSize !== null) {\n    if (defaultSize < 0 || (units === \"percentages\" && defaultSize > 100)) {\n      if (isDevelopment) {\n        console.error(`Invalid Panel defaultSize provided, ${defaultSize}`);\n      }\n\n      panelData.current.defaultSize = null;\n    } else if (defaultSize < minSize && !collapsible) {\n      if (isDevelopment) {\n        console.error(\n          `Panel minSize (${minSize}) cannot be greater than defaultSize (${defaultSize})`\n        );\n      }\n\n      panelData.current.defaultSize = minSize;\n    } else if (maxSize != null && defaultSize > maxSize) {\n      if (isDevelopment) {\n        console.error(\n          `Panel maxSize (${maxSize}) cannot be less than defaultSize (${defaultSize})`\n        );\n      }\n\n      panelData.current.defaultSize = maxSize;\n    }\n  }\n}\n\nexport function validatePanelGroupLayout({\n  groupId,\n  panels,\n  nextSizes,\n  prevSizes,\n  units,\n}: {\n  groupId: string;\n  panels: Map<string, PanelData>;\n  nextSizes: number[];\n  prevSizes: number[];\n  units: Units;\n}): number[] {\n  // Clone because this method modifies\n  nextSizes = [...nextSizes];\n\n  const panelsArray = panelsMapToSortedArray(panels);\n\n  const groupSizePixels =\n    units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n\n  let remainingSize = 0;\n\n  // First, check all of the proposed sizes against the min/max constraints\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    const prevSize = prevSizes[index];\n    const nextSize = nextSizes[index];\n    const safeNextSize = safeResizePanel(\n      units,\n      groupSizePixels,\n      panel,\n      prevSize,\n      nextSize\n    );\n    if (nextSize != safeNextSize) {\n      remainingSize += nextSize - safeNextSize;\n      nextSizes[index] = safeNextSize;\n\n      if (isDevelopment) {\n        console.error(\n          `Invalid size (${nextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`\n        );\n      }\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (remainingSize.toFixed(3) !== \"0.000\") {\n    for (let index = 0; index < panelsArray.length; index++) {\n      const panel = panelsArray[index];\n\n      let { maxSize, minSize } = panel.current;\n\n      if (units === \"pixels\") {\n        minSize = (minSize / groupSizePixels) * 100;\n        if (maxSize != null) {\n          maxSize = (maxSize / groupSizePixels) * 100;\n        }\n      }\n\n      const size = Math.min(\n        maxSize != null ? maxSize : 100,\n        Math.max(minSize, nextSizes[index] + remainingSize)\n      );\n\n      if (size !== nextSizes[index]) {\n        remainingSize -= size - nextSizes[index];\n        nextSizes[index] = size;\n\n        // Fuzzy comparison to account for imprecise floating point math\n        if (Math.abs(remainingSize).toFixed(3) === \"0.000\") {\n          break;\n        }\n      }\n    }\n  }\n\n  // If we still have remainder, the requested layout wasn't valid and we should warn about it\n  if (remainingSize.toFixed(3) !== \"0.000\") {\n    if (isDevelopment) {\n      console.error(\n        `\"Invalid panel group configuration; default panel sizes should total 100% but was ${\n          100 - remainingSize\n        }%`\n      );\n    }\n  }\n\n  return nextSizes;\n}\n","export function assert(\n  expectedCondition: boolean,\n  message: string = \"Assertion failed!\"\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    console.error(message);\n\n    throw Error(message);\n  }\n}\n","export function areEqual(arrayA: any[], arrayB: any[]): boolean {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { PRECISION } from \"../constants\";\nimport { InitialDragState } from \"../PanelGroup\";\nimport { Direction, PanelData, ResizeEvent } from \"../types\";\nimport {\n  getPanelGroup,\n  getResizeHandle,\n  getResizeHandlePanelIds,\n} from \"./group\";\n\nexport type Coordinates = {\n  movement: number;\n  offset: number;\n};\n\nexport type Size = {\n  height: number;\n  width: number;\n};\n\nexport function getDragOffset(\n  event: ResizeEvent,\n  handleId: string,\n  direction: Direction,\n  initialOffset: number = 0,\n  initialHandleElementRect: DOMRect | null = null\n): number {\n  const isHorizontal = direction === \"horizontal\";\n\n  let pointerOffset = 0;\n  if (isMouseEvent(event)) {\n    pointerOffset = isHorizontal ? event.clientX : event.clientY;\n  } else if (isTouchEvent(event)) {\n    const firstTouch = event.touches[0];\n    pointerOffset = isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n  } else {\n    return 0;\n  }\n\n  const handleElement = getResizeHandle(handleId)!;\n  const rect =\n    initialHandleElementRect || handleElement.getBoundingClientRect();\n  const elementOffset = isHorizontal ? rect.left : rect.top;\n\n  return pointerOffset - elementOffset - initialOffset;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nexport function getMovement(\n  event: ResizeEvent,\n  groupId: string,\n  handleId: string,\n  panelsArray: PanelData[],\n  direction: Direction,\n  prevSizes: number[],\n  initialDragState: InitialDragState | null\n): number {\n  const {\n    dragOffset = 0,\n    dragHandleRect,\n    sizes: initialSizes,\n  } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n\n    const groupElement = getPanelGroup(groupId)!;\n    const rect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? rect.width : rect.height;\n\n    const denominator = event.shiftKey ? 10 : 100;\n    const delta = groupSizeInPixels / denominator;\n\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = groupSizeInPixels;\n        break;\n      case \"Home\":\n        movement = -groupSizeInPixels;\n        break;\n    }\n\n    // If the Panel being resized is collapsible,\n    // we need to special case resizing around the minSize boundary.\n    // If contracting, Panels should shrink to their minSize and then snap to fully collapsed.\n    // If expanding from collapsed, they should snap back to their minSize.\n    const [idBefore, idAfter] = getResizeHandlePanelIds(\n      groupId,\n      handleId,\n      panelsArray\n    );\n    const targetPanelId = movement < 0 ? idBefore : idAfter;\n    const targetPanelIndex = panelsArray.findIndex(\n      (panel) => panel.current.id === targetPanelId\n    );\n    const targetPanel = panelsArray[targetPanelIndex];\n    if (targetPanel.current.collapsible) {\n      const baseSize = baseSizes[targetPanelIndex];\n      if (\n        baseSize === 0 ||\n        baseSize.toPrecision(PRECISION) ===\n          targetPanel.current.minSize.toPrecision(PRECISION)\n      ) {\n        movement =\n          movement < 0\n            ? -targetPanel.current.minSize * groupSizeInPixels\n            : targetPanel.current.minSize * groupSizeInPixels;\n      }\n    }\n\n    return movement;\n  } else {\n    return getDragOffset(\n      event,\n      handleId,\n      direction,\n      dragOffset,\n      dragHandleRect\n    );\n  }\n}\n\nexport function isKeyDown(event: ResizeEvent): event is KeyboardEvent {\n  return event.type === \"keydown\";\n}\n\nexport function isMouseEvent(event: ResizeEvent): event is MouseEvent {\n  return event.type.startsWith(\"mouse\");\n}\n\nexport function isTouchEvent(event: ResizeEvent): event is TouchEvent {\n  return event.type.startsWith(\"touch\");\n}\n","type CursorState =\n  | \"horizontal\"\n  | \"horizontal-max\"\n  | \"horizontal-min\"\n  | \"vertical\"\n  | \"vertical-max\"\n  | \"vertical-min\";\n\nlet currentState: CursorState | null = null;\nlet element: HTMLStyleElement | null = null;\n\nexport function getCursorStyle(state: CursorState): string {\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"horizontal-max\":\n      return \"w-resize\";\n    case \"horizontal-min\":\n      return \"e-resize\";\n    case \"vertical\":\n      return \"ns-resize\";\n    case \"vertical-max\":\n      return \"n-resize\";\n    case \"vertical-min\":\n      return \"s-resize\";\n  }\n}\n\nexport function resetGlobalCursorStyle() {\n  if (element !== null) {\n    document.head.removeChild(element);\n\n    currentState = null;\n    element = null;\n  }\n}\n\nexport function setGlobalCursorStyle(state: CursorState) {\n  if (currentState === state) {\n    return;\n  }\n\n  currentState = state;\n\n  const style = getCursorStyle(state);\n\n  if (element === null) {\n    element = document.createElement(\"style\");\n\n    document.head.appendChild(element);\n  }\n\n  element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n","export default function debounce<T extends Function>(\n  callback: T,\n  durationMs: number = 10\n) {\n  let timeoutId: NodeJS.Timeout | null = null;\n\n  let callable = (...args: any) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n\n  return callable as unknown as T;\n}\n","import { PanelData, PanelGroupStorage } from \"../types\";\n\ntype SerializedPanelGroupState = { [panelIds: string]: number[] };\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using an attribute like minSize instead should work well enough.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getSerializationKey(panels: PanelData[]): string {\n  return panels\n    .map((panel) => {\n      const { minSize, order } = panel.current;\n      return order ? `${order}:${minSize}` : `${minSize}`;\n    })\n    .sort((a, b) => a.localeCompare(b))\n    .join(\",\");\n}\n\nfunction loadSerializedPanelGroupState(\n  autoSaveId: string,\n  storage: PanelGroupStorage\n): SerializedPanelGroupState | null {\n  try {\n    const serialized = storage.getItem(`PanelGroup:sizes:${autoSaveId}`);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n\n  return null;\n}\n\nexport function loadPanelLayout(\n  autoSaveId: string,\n  panels: PanelData[],\n  storage: PanelGroupStorage\n): number[] | null {\n  const state = loadSerializedPanelGroupState(autoSaveId, storage);\n  if (state) {\n    const key = getSerializationKey(panels);\n    return state[key] ?? null;\n  }\n\n  return null;\n}\n\nexport function savePanelGroupLayout(\n  autoSaveId: string,\n  panels: PanelData[],\n  sizes: number[],\n  storage: PanelGroupStorage\n): void {\n  const key = getSerializationKey(panels);\n  const state = loadSerializedPanelGroupState(autoSaveId, storage) || {};\n  state[key] = sizes;\n\n  try {\n    storage.setItem(`PanelGroup:sizes:${autoSaveId}`, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n","import {\n  createElement,\n  CSSProperties,\n  ElementType,\n  MouseEvent as ReactMouseEvent,\n  ReactNode,\n  TouchEvent,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"./vendor/react\";\nimport useUniqueId from \"./hooks/useUniqueId\";\n\nimport { useWindowSplitterResizeHandlerBehavior } from \"./hooks/useWindowSplitterBehavior\";\nimport { PanelGroupContext } from \"./PanelContexts\";\nimport type {\n  ResizeHandler,\n  ResizeEvent,\n  PanelResizeHandleOnDragging,\n} from \"./types\";\nimport { getCursorStyle } from \"./utils/cursor\";\n\nexport type PanelResizeHandleProps = {\n  children?: ReactNode;\n  className?: string;\n  disabled?: boolean;\n  id?: string | null;\n  onDragging?: PanelResizeHandleOnDragging;\n  style?: CSSProperties;\n  tagName?: ElementType;\n};\n\nexport function PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  id: idFromProps = null,\n  onDragging,\n  style: styleFromProps = {},\n  tagName: Type = \"div\",\n}: PanelResizeHandleProps) {\n  const divElementRef = useRef<HTMLDivElement>(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef<{\n    onDragging: PanelResizeHandleOnDragging | undefined;\n  }>({ onDragging });\n  useEffect(() => {\n    callbacksRef.current.onDragging = onDragging;\n  });\n\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(\n      `PanelResizeHandle components must be rendered within a PanelGroup container`\n    );\n  }\n\n  const {\n    activeHandleId,\n    direction,\n    groupId,\n    registerResizeHandle,\n    startDragging,\n    stopDragging,\n  } = panelGroupContext;\n\n  const resizeHandleId = useUniqueId(idFromProps);\n  const isDragging = activeHandleId === resizeHandleId;\n\n  const [isFocused, setIsFocused] = useState(false);\n\n  const [resizeHandler, setResizeHandler] = useState<ResizeHandler | null>(\n    null\n  );\n\n  const stopDraggingAndBlur = useCallback(() => {\n    // Clicking on the drag handle shouldn't leave it focused;\n    // That would cause the PanelGroup to think it was still active.\n    const div = divElementRef.current!;\n    div.blur();\n\n    stopDragging();\n\n    const { onDragging } = callbacksRef.current;\n    if (onDragging) {\n      onDragging(false);\n    }\n  }, [stopDragging]);\n\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandle(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandle]);\n\n  useEffect(() => {\n    if (disabled || resizeHandler == null || !isDragging) {\n      return;\n    }\n\n    const onMove = (event: ResizeEvent) => {\n      resizeHandler(event);\n    };\n\n    const onMouseLeave = (event: MouseEvent) => {\n      resizeHandler(event);\n    };\n\n    const divElement = divElementRef.current!;\n    const targetDocument = divElement.ownerDocument;\n\n    targetDocument.body.addEventListener(\"contextmenu\", stopDraggingAndBlur);\n    targetDocument.body.addEventListener(\"mousemove\", onMove);\n    targetDocument.body.addEventListener(\"touchmove\", onMove);\n    targetDocument.body.addEventListener(\"mouseleave\", onMouseLeave);\n    window.addEventListener(\"mouseup\", stopDraggingAndBlur);\n    window.addEventListener(\"touchend\", stopDraggingAndBlur);\n\n    return () => {\n      targetDocument.body.removeEventListener(\n        \"contextmenu\",\n        stopDraggingAndBlur\n      );\n      targetDocument.body.removeEventListener(\"mousemove\", onMove);\n      targetDocument.body.removeEventListener(\"touchmove\", onMove);\n      targetDocument.body.removeEventListener(\"mouseleave\", onMouseLeave);\n      window.removeEventListener(\"mouseup\", stopDraggingAndBlur);\n      window.removeEventListener(\"touchend\", stopDraggingAndBlur);\n    };\n  }, [direction, disabled, isDragging, resizeHandler, stopDraggingAndBlur]);\n\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler,\n  });\n\n  const style: CSSProperties = {\n    cursor: getCursorStyle(direction),\n    touchAction: \"none\",\n    userSelect: \"none\",\n  };\n\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-resize-handle-active\": isDragging\n      ? \"pointer\"\n      : isFocused\n      ? \"keyboard\"\n      : undefined,\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId,\n    onBlur: () => setIsFocused(false),\n    onFocus: () => setIsFocused(true),\n    onMouseDown: (event: ReactMouseEvent) => {\n      startDragging(resizeHandleId, event.nativeEvent);\n\n      const { onDragging } = callbacksRef.current!;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    onMouseUp: stopDraggingAndBlur,\n    onTouchCancel: stopDraggingAndBlur,\n    onTouchEnd: stopDraggingAndBlur,\n    onTouchStart: (event: TouchEvent) => {\n      startDragging(resizeHandleId, event.nativeEvent);\n\n      const { onDragging } = callbacksRef.current!;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    ref: divElementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps,\n    },\n    tabIndex: 0,\n  });\n}\n\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n"],"names":[],"version":3,"file":"react-resizable-panels.esm.js.map","sourceRoot":"../../../"}