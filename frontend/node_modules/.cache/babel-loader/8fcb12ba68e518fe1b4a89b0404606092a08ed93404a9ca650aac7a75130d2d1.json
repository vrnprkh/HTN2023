{"ast":null,"code":"export class Stream {\n  constructor(response, controller) {\n    this.response = response;\n    this.controller = controller;\n    this.decoder = new SSEDecoder();\n  }\n  async *iterMessages() {\n    if (!this.response.body) {\n      this.controller.abort();\n      throw new Error(`Attempted to iterate over a response with no body`);\n    }\n    const lineDecoder = new LineDecoder();\n    const iter = readableStreamAsyncIterable(this.response.body);\n    for await (const chunk of iter) {\n      for (const line of lineDecoder.decode(chunk)) {\n        const sse = this.decoder.decode(line);\n        if (sse) yield sse;\n      }\n    }\n    for (const line of lineDecoder.flush()) {\n      const sse = this.decoder.decode(line);\n      if (sse) yield sse;\n    }\n  }\n  async *[Symbol.asyncIterator]() {\n    let done = false;\n    try {\n      for await (const sse of this.iterMessages()) {\n        if (done) continue;\n        if (sse.data.startsWith('[DONE]')) {\n          done = true;\n          continue;\n        }\n        if (sse.event === null) {\n          try {\n            yield JSON.parse(sse.data);\n          } catch (e) {\n            console.error(`Could not parse message into JSON:`, sse.data);\n            console.error(`From chunk:`, sse.raw);\n            throw e;\n          }\n        }\n      }\n      done = true;\n    } catch (e) {\n      // If the user calls `stream.controller.abort()`, we should exit without throwing.\n      if (e instanceof Error && e.name === 'AbortError') return;\n      throw e;\n    } finally {\n      // If the user `break`s, abort the ongoing request.\n      if (!done) this.controller.abort();\n    }\n  }\n}\nclass SSEDecoder {\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n  decode(line) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n      const sse = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks\n      };\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n      return sse;\n    }\n    this.chunks.push(line);\n    if (line.startsWith(':')) {\n      return null;\n    }\n    let [fieldname, _, value] = partition(line, ':');\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n    return null;\n  }\n}\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n  constructor() {\n    this.buffer = [];\n    this.trailingCR = false;\n  }\n  decode(chunk) {\n    let text = this.decodeText(chunk);\n    if (this.trailingCR) {\n      text = '\\r' + text;\n      this.trailingCR = false;\n    }\n    if (text.endsWith('\\r')) {\n      this.trailingCR = true;\n      text = text.slice(0, -1);\n    }\n    if (!text) {\n      return [];\n    }\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n    if (lines.length === 1 && !trailingNewline) {\n      this.buffer.push(lines[0]);\n      return [];\n    }\n    if (this.buffer.length > 0) {\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n      this.buffer = [];\n    }\n    if (!trailingNewline) {\n      this.buffer = [lines.pop() || ''];\n    }\n    return lines;\n  }\n  decodeText(bytes) {\n    var _a;\n    if (bytes == null) return '';\n    if (typeof bytes === 'string') return bytes;\n    // Node:\n    if (typeof Buffer !== 'undefined') {\n      if (bytes instanceof Buffer) {\n        return bytes.toString();\n      }\n      if (bytes instanceof Uint8Array) {\n        return Buffer.from(bytes).toString();\n      }\n      throw new Error(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`);\n    }\n    // Browser\n    if (typeof TextDecoder !== 'undefined') {\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n        (_a = this.textDecoder) !== null && _a !== void 0 ? _a : this.textDecoder = new TextDecoder('utf8');\n        return this.textDecoder.decode(bytes);\n      }\n      throw new Error(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);\n    }\n    throw new Error(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);\n  }\n  flush() {\n    if (!this.buffer.length && !this.trailingCR) {\n      return [];\n    }\n    const lines = [this.buffer.join('')];\n    this.buffer = [];\n    this.trailingCR = false;\n    return lines;\n  }\n}\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', '\\u2028', '\\u2029']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\nfunction partition(str, delimiter) {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n  return [str, '', ''];\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nfunction readableStreamAsyncIterable(stream) {\n  if (stream[Symbol.asyncIterator]) return stream;\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result === null || result === void 0 ? void 0 : result.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return {\n        done: true,\n        value: undefined\n      };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}","map":{"version":3,"names":["Stream","constructor","response","controller","decoder","SSEDecoder","iterMessages","body","abort","Error","lineDecoder","LineDecoder","iter","readableStreamAsyncIterable","chunk","line","decode","sse","flush","Symbol","asyncIterator","done","data","startsWith","JSON","parse","e","error","raw","name","endsWith","substring","length","event","join","chunks","push","_","value","partition","fieldname","buffer","trailingCR","text","slice","NEWLINE_CHARS","has","split","NEWLINE_REGEXP","trailingNewline","lines","pop","decodeText","bytes","_a","Buffer","toString","Uint8Array","from","TextDecoder","ArrayBuffer","textDecoder","Set","str","delimiter","index","indexOf","stream","result","reader","read","releaseLock","return","cancel","undefined"],"sources":["/home/zain/HTN2023/node_modules/openai/src/streaming.ts"],"sourcesContent":["import type { Response } from './_shims/fetch.js';\n\ntype Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\n\ntype ServerSentEvent = {\n  event: string | null;\n  data: string;\n  raw: string[];\n};\n\nexport class Stream<Item> implements AsyncIterable<Item> {\n  controller: AbortController;\n\n  private response: Response;\n  private decoder: SSEDecoder;\n\n  constructor(response: Response, controller: AbortController) {\n    this.response = response;\n    this.controller = controller;\n    this.decoder = new SSEDecoder();\n  }\n\n  private async *iterMessages(): AsyncGenerator<ServerSentEvent, void, unknown> {\n    if (!this.response.body) {\n      this.controller.abort();\n      throw new Error(`Attempted to iterate over a response with no body`);\n    }\n    const lineDecoder = new LineDecoder();\n\n    const iter = readableStreamAsyncIterable<Bytes>(this.response.body);\n    for await (const chunk of iter) {\n      for (const line of lineDecoder.decode(chunk)) {\n        const sse = this.decoder.decode(line);\n        if (sse) yield sse;\n      }\n    }\n\n    for (const line of lineDecoder.flush()) {\n      const sse = this.decoder.decode(line);\n      if (sse) yield sse;\n    }\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<Item, any, undefined> {\n    let done = false;\n    try {\n      for await (const sse of this.iterMessages()) {\n        if (done) continue;\n\n        if (sse.data.startsWith('[DONE]')) {\n          done = true;\n          continue;\n        }\n\n        if (sse.event === null) {\n          try {\n            yield JSON.parse(sse.data);\n          } catch (e) {\n            console.error(`Could not parse message into JSON:`, sse.data);\n            console.error(`From chunk:`, sse.raw);\n            throw e;\n          }\n        }\n      }\n      done = true;\n    } catch (e) {\n      // If the user calls `stream.controller.abort()`, we should exit without throwing.\n      if (e instanceof Error && e.name === 'AbortError') return;\n      throw e;\n    } finally {\n      // If the user `break`s, abort the ongoing request.\n      if (!done) this.controller.abort();\n    }\n  }\n}\n\nclass SSEDecoder {\n  private data: string[];\n  private event: string | null;\n  private chunks: string[];\n\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n\n  decode(line: string) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n\n      const sse: ServerSentEvent = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks,\n      };\n\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n\n      return sse;\n    }\n\n    this.chunks.push(line);\n\n    if (line.startsWith(':')) {\n      return null;\n    }\n\n    let [fieldname, _, value] = partition(line, ':');\n\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n\n    return null;\n  }\n}\n\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n  // prettier-ignore\n  static NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', '\\u2028', '\\u2029']);\n  static NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\n\n  buffer: string[];\n  trailingCR: boolean;\n  textDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either \"dom\" or \"node\" types.\n\n  constructor() {\n    this.buffer = [];\n    this.trailingCR = false;\n  }\n\n  decode(chunk: Bytes): string[] {\n    let text = this.decodeText(chunk);\n\n    if (this.trailingCR) {\n      text = '\\r' + text;\n      this.trailingCR = false;\n    }\n    if (text.endsWith('\\r')) {\n      this.trailingCR = true;\n      text = text.slice(0, -1);\n    }\n\n    if (!text) {\n      return [];\n    }\n\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n\n    if (lines.length === 1 && !trailingNewline) {\n      this.buffer.push(lines[0]!);\n      return [];\n    }\n\n    if (this.buffer.length > 0) {\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n      this.buffer = [];\n    }\n\n    if (!trailingNewline) {\n      this.buffer = [lines.pop() || ''];\n    }\n\n    return lines;\n  }\n\n  decodeText(bytes: Bytes): string {\n    if (bytes == null) return '';\n    if (typeof bytes === 'string') return bytes;\n\n    // Node:\n    if (typeof Buffer !== 'undefined') {\n      if (bytes instanceof Buffer) {\n        return bytes.toString();\n      }\n      if (bytes instanceof Uint8Array) {\n        return Buffer.from(bytes).toString();\n      }\n\n      throw new Error(\n        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`,\n      );\n    }\n\n    // Browser\n    if (typeof TextDecoder !== 'undefined') {\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n        this.textDecoder ??= new TextDecoder('utf8');\n        return this.textDecoder.decode(bytes);\n      }\n\n      throw new Error(\n        `Unexpected: received non-Uint8Array/ArrayBuffer (${\n          (bytes as any).constructor.name\n        }) in a web platform. Please report this error.`,\n      );\n    }\n\n    throw new Error(\n      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,\n    );\n  }\n\n  flush(): string[] {\n    if (!this.buffer.length && !this.trailingCR) {\n      return [];\n    }\n\n    const lines = [this.buffer.join('')];\n    this.buffer = [];\n    this.trailingCR = false;\n    return lines;\n  }\n}\n\nfunction partition(str: string, delimiter: string): [string, string, string] {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n\n  return [str, '', ''];\n}\n\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nfunction readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\n  if (stream[Symbol.asyncIterator]) return stream;\n\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return { done: true, value: undefined };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}