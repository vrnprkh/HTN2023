{"ast":null,"code":"import * as React from 'react';\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n\n// eslint-disable-next-line no-restricted-imports\n\nconst {\n  createElement,\n  createContext,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState\n} = React;\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = React[\"useId\".toString()];\nconst useIsomorphicLayoutEffect = useLayoutEffect;\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idRef.current;\n}\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\nfunction PanelWithForwardedRef({\n  children = null,\n  className: classNameFromProps = \"\",\n  collapsedSize = 0,\n  collapsible = false,\n  defaultSize = null,\n  forwardedRef,\n  id: idFromProps = null,\n  maxSize = null,\n  minSize,\n  onCollapse = null,\n  onResize = null,\n  order = null,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const panelId = useUniqueId(idFromProps);\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    registerPanel,\n    resizePanel,\n    units,\n    unregisterPanel\n  } = context;\n  if (minSize == null) {\n    if (units === \"percentages\") {\n      // Mimics legacy default value for percentage based panel groups\n      minSize = 10;\n    } else {\n      // There is no meaningful minimum pixel default we can provide\n      minSize = 0;\n    }\n  }\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onCollapse,\n    onResize\n  });\n  useEffect(() => {\n    callbacksRef.current.onCollapse = onCollapse;\n    callbacksRef.current.onResize = onResize;\n  });\n  const style = getPanelStyle(panelId, defaultSize);\n  const committedValuesRef = useRef({\n    size: parseSizeFromStyle(style)\n  });\n  const panelDataRef = useRef({\n    callbacksRef,\n    collapsedSize,\n    collapsible,\n    defaultSize,\n    id: panelId,\n    idWasAutoGenerated: idFromProps == null,\n    maxSize,\n    minSize,\n    order\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.size = parseSizeFromStyle(style);\n    panelDataRef.current.callbacksRef = callbacksRef;\n    panelDataRef.current.collapsedSize = collapsedSize;\n    panelDataRef.current.collapsible = collapsible;\n    panelDataRef.current.defaultSize = defaultSize;\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idWasAutoGenerated = idFromProps == null;\n    panelDataRef.current.maxSize = maxSize;\n    panelDataRef.current.minSize = minSize;\n    panelDataRef.current.order = order;\n  });\n  useIsomorphicLayoutEffect(() => {\n    registerPanel(panelId, panelDataRef);\n    return () => {\n      unregisterPanel(panelId);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => collapsePanel(panelId),\n    expand: () => expandPanel(panelId),\n    getCollapsed() {\n      return committedValuesRef.current.size === 0;\n    },\n    getId() {\n      return panelId;\n    },\n    getSize(units) {\n      return getPanelSize(panelId, units);\n    },\n    resize: (percentage, units) => resizePanel(panelId, percentage, units)\n  }), [collapsePanel, expandPanel, getPanelSize, panelId, resizePanel]);\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-panel\": \"\",\n    \"data-panel-collapsible\": collapsible || undefined,\n    \"data-panel-id\": panelId,\n    \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1),\n    id: `data-panel-id-${panelId}`,\n    style: {\n      ...style,\n      ...styleFromProps\n    }\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\n// HACK\nfunction parseSizeFromStyle(style) {\n  const {\n    flexGrow\n  } = style;\n  if (typeof flexGrow === \"string\") {\n    return parseFloat(flexGrow);\n  } else {\n    return flexGrow;\n  }\n}\nconst PRECISION = 10;\nfunction adjustByDelta(event, committedValues, idBefore, idAfter, deltaPixels, prevSizes, panelSizeBeforeCollapse, initialDragState) {\n  const {\n    id: groupId,\n    panels,\n    units\n  } = committedValues;\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  const {\n    sizes: initialSizes\n  } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n  const panelsArray = panelsMapToSortedArray(panels);\n  const nextSizes = baseSizes.concat();\n  let deltaApplied = 0;\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel immediately after the resizer should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel immediately before the resizer should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resizer.\n\n  // Max-bounds check the panel being expanded first.\n  {\n    const pivotId = deltaPixels < 0 ? idAfter : idBefore;\n    const index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n    const nextSize = safeResizePanel(units, groupSizePixels, panel, baseSize, baseSize + Math.abs(deltaPixels), event);\n    if (baseSize === nextSize) {\n      // If there's no room for the pivot panel to grow, we can ignore this drag update.\n      return baseSizes;\n    } else {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(pivotId, baseSize);\n      }\n      deltaPixels = deltaPixels < 0 ? baseSize - nextSize : nextSize - baseSize;\n    }\n  }\n  let pivotId = deltaPixels < 0 ? idBefore : idAfter;\n  let index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n  while (true) {\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n    const deltaRemaining = Math.abs(deltaPixels) - Math.abs(deltaApplied);\n    const nextSize = safeResizePanel(units, groupSizePixels, panel, baseSize, baseSize - deltaRemaining, event);\n    if (baseSize !== nextSize) {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(panel.current.id, baseSize);\n      }\n      deltaApplied += baseSize - nextSize;\n      nextSizes[index] = nextSize;\n      if (deltaApplied.toPrecision(PRECISION).localeCompare(Math.abs(deltaPixels).toPrecision(PRECISION), undefined, {\n        numeric: true\n      }) >= 0) {\n        break;\n      }\n    }\n    if (deltaPixels < 0) {\n      if (--index < 0) {\n        break;\n      }\n    } else {\n      if (++index >= panelsArray.length) {\n        break;\n      }\n    }\n  }\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore the \"mousemove\" event.\n  if (deltaApplied === 0) {\n    return baseSizes;\n  }\n\n  // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n  pivotId = deltaPixels < 0 ? idAfter : idBefore;\n  index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n  nextSizes[index] = baseSizes[index] + deltaApplied;\n  return nextSizes;\n}\nfunction callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap) {\n  sizes.forEach((size, index) => {\n    const panelRef = panelsArray[index];\n    if (!panelRef) {\n      // Handle initial mount (when panels are registered too late to be in the panels array)\n      // The subsequent render+effects will handle the resize notification\n      return;\n    }\n    const {\n      callbacksRef,\n      collapsedSize,\n      collapsible,\n      id\n    } = panelRef.current;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[id];\n    if (lastNotifiedSize !== size) {\n      panelIdToLastNotifiedSizeMap[id] = size;\n      const {\n        onCollapse,\n        onResize\n      } = callbacksRef.current;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && onCollapse) {\n        if ((lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size !== collapsedSize) {\n          onCollapse(false);\n        } else if (lastNotifiedSize !== collapsedSize && size === collapsedSize) {\n          onCollapse(true);\n        }\n      }\n    }\n  });\n}\nfunction calculateDefaultLayout({\n  groupId,\n  panels,\n  units\n}) {\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  const panelsArray = panelsMapToSortedArray(panels);\n  const sizes = Array(panelsArray.length);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Assigning default sizes requires a couple of passes:\n  // First, all panels with defaultSize should be set as-is\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    const {\n      defaultSize\n    } = panel.current;\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      sizes[index] = units === \"pixels\" ? defaultSize / groupSizePixels * 100 : defaultSize;\n      remainingSize -= sizes[index];\n    }\n  }\n\n  // Remaining total size should be distributed evenly between panels\n  // This may require two passes, depending on min/max constraints\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    let {\n      defaultSize,\n      id,\n      maxSize,\n      minSize\n    } = panel.current;\n    if (defaultSize != null) {\n      continue;\n    }\n    if (units === \"pixels\") {\n      minSize = minSize / groupSizePixels * 100;\n      if (maxSize != null) {\n        maxSize = maxSize / groupSizePixels * 100;\n      }\n    }\n    const remainingPanels = panelsArray.length - numPanelsWithSizes;\n    const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, remainingSize / remainingPanels));\n    sizes[index] = size;\n    numPanelsWithSizes++;\n    remainingSize -= size;\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (remainingSize !== 0) {\n    for (let index = 0; index < panelsArray.length; index++) {\n      const panel = panelsArray[index];\n      let {\n        maxSize,\n        minSize\n      } = panel.current;\n      if (units === \"pixels\") {\n        minSize = minSize / groupSizePixels * 100;\n        if (maxSize != null) {\n          maxSize = maxSize / groupSizePixels * 100;\n        }\n      }\n      const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, sizes[index] + remainingSize));\n      if (size !== sizes[index]) {\n        remainingSize -= size - sizes[index];\n        sizes[index] = size;\n\n        // Fuzzy comparison to account for imprecise floating point math\n        if (Math.abs(remainingSize).toFixed(3) === \"0.000\") {\n          break;\n        }\n      }\n    }\n  }\n\n  // Finally, if there is still left-over size, log an error\n  if (Math.abs(remainingSize).toFixed(3) !== \"0.000\") {\n    {\n      console.error(`Invalid panel group configuration; default panel sizes should total 100% but was ${(100 - remainingSize).toFixed(1)}%. This can cause the cursor to become misaligned while dragging.`);\n    }\n  }\n  return sizes;\n}\nfunction getBeforeAndAfterIds(id, panelsArray) {\n  if (panelsArray.length < 2) {\n    return [null, null];\n  }\n  const index = panelsArray.findIndex(panel => panel.current.id === id);\n  if (index < 0) {\n    return [null, null];\n  }\n  const isLastPanel = index === panelsArray.length - 1;\n  const idBefore = isLastPanel ? panelsArray[index - 1].current.id : id;\n  const idAfter = isLastPanel ? id : panelsArray[index + 1].current.id;\n  return [idBefore, idAfter];\n}\nfunction getAvailableGroupSizePixels(groupId) {\n  const panelGroupElement = getPanelGroup(groupId);\n  if (panelGroupElement == null) {\n    return NaN;\n  }\n  const direction = panelGroupElement.getAttribute(\"data-panel-group-direction\");\n  const resizeHandles = getResizeHandlesForGroup(groupId);\n  if (direction === \"horizontal\") {\n    return panelGroupElement.offsetWidth - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetWidth;\n    }, 0);\n  } else {\n    return panelGroupElement.offsetHeight - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetHeight;\n    }, 0);\n  }\n}\n\n// This method returns a number between 1 and 100 representing\n// the % of the group's overall space this panel should occupy.\nfunction getFlexGrow(panels, id, sizes) {\n  if (panels.size === 1) {\n    return \"100\";\n  }\n  const panelsArray = panelsMapToSortedArray(panels);\n  const index = panelsArray.findIndex(panel => panel.current.id === id);\n  const size = sizes[index];\n  if (size == null) {\n    return \"0\";\n  }\n  return size.toPrecision(PRECISION);\n}\nfunction getPanel(id) {\n  const element = document.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getPanelGroup(id) {\n  const element = document.querySelector(`[data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandle(id) {\n  const element = document.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandleIndex(id) {\n  const handles = getResizeHandles();\n  const index = handles.findIndex(handle => handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n  return index ?? null;\n}\nfunction getResizeHandles() {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id]`));\n}\nfunction getResizeHandlesForGroup(groupId) {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray) {\n  const handle = getResizeHandle(handleId);\n  const handles = getResizeHandlesForGroup(groupId);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = panelsArray[index]?.current?.id ?? null;\n  const idAfter = panelsArray[index + 1]?.current?.id ?? null;\n  return [idBefore, idAfter];\n}\nfunction panelsMapToSortedArray(panels) {\n  return Array.from(panels.values()).sort((panelA, panelB) => {\n    const orderA = panelA.current.order;\n    const orderB = panelB.current.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction safeResizePanel(units, groupSizePixels, panel, prevSize, nextSize, event = null) {\n  let {\n    collapsedSize,\n    collapsible,\n    maxSize,\n    minSize\n  } = panel.current;\n  if (units === \"pixels\") {\n    collapsedSize = collapsedSize / groupSizePixels * 100;\n    if (maxSize != null) {\n      maxSize = maxSize / groupSizePixels * 100;\n    }\n    minSize = minSize / groupSizePixels * 100;\n  }\n  if (collapsible) {\n    if (prevSize > collapsedSize) {\n      // Mimic VS COde behavior; collapse a panel if it's smaller than half of its min-size\n      if (nextSize <= minSize / 2 + collapsedSize) {\n        return collapsedSize;\n      }\n    } else {\n      const isKeyboardEvent = event?.type?.startsWith(\"key\");\n      if (!isKeyboardEvent) {\n        // Keyboard events should expand a collapsed panel to the min size,\n        // but mouse events should wait until the panel has reached its min size\n        // to avoid a visual flickering when dragging between collapsed and min size.\n        if (nextSize < minSize) {\n          return collapsedSize;\n        }\n      }\n    }\n  }\n  return Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSize));\n}\nfunction validatePanelProps(units, panelData) {\n  const {\n    collapsible,\n    defaultSize,\n    maxSize,\n    minSize\n  } = panelData.current;\n\n  // Basic props validation\n  if (minSize < 0 || units === \"percentages\" && minSize > 100) {\n    {\n      console.error(`Invalid Panel minSize provided, ${minSize}`);\n    }\n    panelData.current.minSize = 0;\n  }\n  if (maxSize != null) {\n    if (maxSize < 0 || units === \"percentages\" && maxSize > 100) {\n      {\n        console.error(`Invalid Panel maxSize provided, ${maxSize}`);\n      }\n      panelData.current.maxSize = null;\n    }\n  }\n  if (defaultSize !== null) {\n    if (defaultSize < 0 || units === \"percentages\" && defaultSize > 100) {\n      {\n        console.error(`Invalid Panel defaultSize provided, ${defaultSize}`);\n      }\n      panelData.current.defaultSize = null;\n    } else if (defaultSize < minSize && !collapsible) {\n      {\n        console.error(`Panel minSize (${minSize}) cannot be greater than defaultSize (${defaultSize})`);\n      }\n      panelData.current.defaultSize = minSize;\n    } else if (maxSize != null && defaultSize > maxSize) {\n      {\n        console.error(`Panel maxSize (${maxSize}) cannot be less than defaultSize (${defaultSize})`);\n      }\n      panelData.current.defaultSize = maxSize;\n    }\n  }\n}\nfunction validatePanelGroupLayout({\n  groupId,\n  panels,\n  nextSizes,\n  prevSizes,\n  units\n}) {\n  // Clone because this method modifies\n  nextSizes = [...nextSizes];\n  const panelsArray = panelsMapToSortedArray(panels);\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  let remainingSize = 0;\n\n  // First, check all of the proposed sizes against the min/max constraints\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    const prevSize = prevSizes[index];\n    const nextSize = nextSizes[index];\n    const safeNextSize = safeResizePanel(units, groupSizePixels, panel, prevSize, nextSize);\n    if (nextSize != safeNextSize) {\n      remainingSize += nextSize - safeNextSize;\n      nextSizes[index] = safeNextSize;\n      {\n        console.error(`Invalid size (${nextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`);\n      }\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (remainingSize.toFixed(3) !== \"0.000\") {\n    for (let index = 0; index < panelsArray.length; index++) {\n      const panel = panelsArray[index];\n      let {\n        maxSize,\n        minSize\n      } = panel.current;\n      if (units === \"pixels\") {\n        minSize = minSize / groupSizePixels * 100;\n        if (maxSize != null) {\n          maxSize = maxSize / groupSizePixels * 100;\n        }\n      }\n      const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSizes[index] + remainingSize));\n      if (size !== nextSizes[index]) {\n        remainingSize -= size - nextSizes[index];\n        nextSizes[index] = size;\n\n        // Fuzzy comparison to account for imprecise floating point math\n        if (Math.abs(remainingSize).toFixed(3) === \"0.000\") {\n          break;\n        }\n      }\n    }\n  }\n\n  // If we still have remainder, the requested layout wasn't valid and we should warn about it\n  if (remainingSize.toFixed(3) !== \"0.000\") {\n    {\n      console.error(`\"Invalid panel group configuration; default panel sizes should total 100% but was ${100 - remainingSize}%`);\n    }\n  }\n  return nextSizes;\n}\nfunction assert(expectedCondition, message = \"Assertion failed!\") {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  groupId,\n  panels,\n  setSizes,\n  sizes,\n  panelSizeBeforeCollapse\n}) {\n  useEffect(() => {\n    const {\n      direction,\n      panels\n    } = committedValuesRef.current;\n    const groupElement = getPanelGroup(groupId);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const {\n      height,\n      width\n    } = groupElement.getBoundingClientRect();\n    const handles = getResizeHandlesForGroup(groupId);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n      const panelsArray = panelsMapToSortedArray(panels);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      let currentMinSize = 0;\n      let currentMaxSize = 100;\n      let totalMinSize = 0;\n      let totalMaxSize = 0;\n\n      // A panel's effective min/max sizes also need to account for other panel's sizes.\n      panelsArray.forEach(panelData => {\n        const {\n          id,\n          maxSize,\n          minSize\n        } = panelData.current;\n        if (id === idBefore) {\n          currentMinSize = minSize;\n          currentMaxSize = maxSize != null ? maxSize : 100;\n        } else {\n          totalMinSize += minSize;\n          totalMaxSize += maxSize != null ? maxSize : 100;\n        }\n      });\n      const ariaValueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n      const ariaValueMin = Math.max(currentMinSize, (panelsArray.length - 1) * 100 - totalMaxSize);\n      const flexGrow = getFlexGrow(panels, idBefore, sizes);\n      handle.setAttribute(\"aria-valuemax\", \"\" + Math.round(ariaValueMax));\n      handle.setAttribute(\"aria-valuemin\", \"\" + Math.round(ariaValueMin));\n      handle.setAttribute(\"aria-valuenow\", \"\" + Math.round(parseInt(flexGrow)));\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelsArray.findIndex(panel => panel.current.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelsArray[index];\n                const size = sizes[index];\n                if (size != null) {\n                  let delta = 0;\n                  if (size.toPrecision(PRECISION) <= panelData.current.minSize.toPrecision(PRECISION)) {\n                    delta = direction === \"horizontal\" ? width : height;\n                  } else {\n                    delta = -(direction === \"horizontal\" ? width : height);\n                  }\n                  const nextSizes = adjustByDelta(event, committedValuesRef.current, idBefore, idAfter, delta, sizes, panelSizeBeforeCollapse.current, null);\n                  if (sizes !== nextSizes) {\n                    setSizes(nextSizes);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      const panelBefore = getPanel(idBefore);\n      if (panelBefore != null) {\n        handle.setAttribute(\"aria-controls\", panelBefore.id);\n      }\n      return () => {\n        handle.removeAttribute(\"aria-valuemax\");\n        handle.removeAttribute(\"aria-valuemin\");\n        handle.removeAttribute(\"aria-valuenow\");\n        handle.removeEventListener(\"keydown\", onKeyDown);\n        if (panelBefore != null) {\n          handle.removeAttribute(\"aria-controls\");\n        }\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [committedValuesRef, groupId, panels, panelSizeBeforeCollapse, setSizes, sizes]);\n}\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const handleElement = getResizeHandle(handleId);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const handles = getResizeHandles();\n            const index = getResizeHandleIndex(handleId);\n            assert(index !== null);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [disabled, handleId, resizeHandler]);\n}\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getDragOffset(event, handleId, direction, initialOffset = 0, initialHandleElementRect = null) {\n  const isHorizontal = direction === \"horizontal\";\n  let pointerOffset = 0;\n  if (isMouseEvent(event)) {\n    pointerOffset = isHorizontal ? event.clientX : event.clientY;\n  } else if (isTouchEvent(event)) {\n    const firstTouch = event.touches[0];\n    pointerOffset = isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n  } else {\n    return 0;\n  }\n  const handleElement = getResizeHandle(handleId);\n  const rect = initialHandleElementRect || handleElement.getBoundingClientRect();\n  const elementOffset = isHorizontal ? rect.left : rect.top;\n  return pointerOffset - elementOffset - initialOffset;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragState) {\n  const {\n    dragOffset = 0,\n    dragHandleRect,\n    sizes: initialSizes\n  } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    const groupElement = getPanelGroup(groupId);\n    const rect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? rect.width : rect.height;\n    const denominator = event.shiftKey ? 10 : 100;\n    const delta = groupSizeInPixels / denominator;\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = groupSizeInPixels;\n        break;\n      case \"Home\":\n        movement = -groupSizeInPixels;\n        break;\n    }\n\n    // If the Panel being resized is collapsible,\n    // we need to special case resizing around the minSize boundary.\n    // If contracting, Panels should shrink to their minSize and then snap to fully collapsed.\n    // If expanding from collapsed, they should snap back to their minSize.\n    const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n    const targetPanelId = movement < 0 ? idBefore : idAfter;\n    const targetPanelIndex = panelsArray.findIndex(panel => panel.current.id === targetPanelId);\n    const targetPanel = panelsArray[targetPanelIndex];\n    if (targetPanel.current.collapsible) {\n      const baseSize = baseSizes[targetPanelIndex];\n      if (baseSize === 0 || baseSize.toPrecision(PRECISION) === targetPanel.current.minSize.toPrecision(PRECISION)) {\n        movement = movement < 0 ? -targetPanel.current.minSize * groupSizeInPixels : targetPanel.current.minSize * groupSizeInPixels;\n      }\n    }\n    return movement;\n  } else {\n    return getDragOffset(event, handleId, direction, dragOffset, dragHandleRect);\n  }\n}\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\nfunction isTouchEvent(event) {\n  return event.type.startsWith(\"touch\");\n}\nlet currentState = null;\nlet element = null;\nfunction getCursorStyle(state) {\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"horizontal-max\":\n      return \"w-resize\";\n    case \"horizontal-min\":\n      return \"e-resize\";\n    case \"vertical\":\n      return \"ns-resize\";\n    case \"vertical-max\":\n      return \"n-resize\";\n    case \"vertical-min\":\n      return \"s-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (element !== null) {\n    document.head.removeChild(element);\n    currentState = null;\n    element = null;\n  }\n}\nfunction setGlobalCursorStyle(state) {\n  if (currentState === state) {\n    return;\n  }\n  currentState = state;\n  const style = getCursorStyle(state);\n  if (element === null) {\n    element = document.createElement(\"style\");\n    document.head.appendChild(element);\n  }\n  element.innerHTML = `*{cursor: ${style}!important;}`;\n}\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using an attribute like minSize instead should work well enough.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getSerializationKey(panels) {\n  return panels.map(panel => {\n    const {\n      minSize,\n      order\n    } = panel.current;\n    return order ? `${order}:${minSize}` : `${minSize}`;\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const serialized = storage.getItem(`PanelGroup:sizes:${autoSaveId}`);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelLayout(autoSaveId, panels, storage) {\n  const state = loadSerializedPanelGroupState(autoSaveId, storage);\n  if (state) {\n    const key = getSerializationKey(panels);\n    return state[key] ?? null;\n  }\n  return null;\n}\nfunction savePanelGroupLayout(autoSaveId, panels, sizes, storage) {\n  const key = getSerializationKey(panels);\n  const state = loadSerializedPanelGroupState(autoSaveId, storage) || {};\n  state[key] = sizes;\n  try {\n    storage.setItem(`PanelGroup:sizes:${autoSaveId}`, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\nconst debounceMap = {};\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\n\n// Initial drag state serves a few purposes:\n// * dragOffset:\n//   Resize is calculated by the distance between the current pointer event and the resize handle being \"dragged\"\n//   This value accounts for the initial offset when the touch/click starts, so the handle doesn't appear to \"jump\"\n// * dragHandleRect, sizes:\n//   When resizing is done via mouse/touch event– some initial state is stored\n//   so that any panels that contract will also expand if drag direction is reversed.\nfunction PanelGroupWithForwardedRef({\n  autoSaveId,\n  children = null,\n  className: classNameFromProps = \"\",\n  direction,\n  disablePointerEventsDuringResize = false,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout,\n  storage = defaultStorage,\n  style: styleFromProps = {},\n  tagName: Type = \"div\",\n  units = \"percentages\"\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const [activeHandleId, setActiveHandleId] = useState(null);\n  const [panels, setPanels] = useState(new Map());\n\n  // When resizing is done via mouse/touch event–\n  // We store the initial Panel sizes in this ref, and apply move deltas to them instead of to the current sizes.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const initialDragStateRef = useRef(null);\n  const devWarningsRef = useRef({\n    didLogDefaultSizeWarning: false,\n    didLogIdAndOrderWarning: false,\n    didLogInvalidLayoutWarning: false,\n    prevPanelIds: []\n  });\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onLayout\n  });\n  useEffect(() => {\n    callbacksRef.current.onLayout = onLayout;\n  });\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n\n  // 0-1 values representing the relative size of each panel.\n  const [sizes, setSizes] = useState([]);\n\n  // Used to support imperative collapse/expand API.\n  const panelSizeBeforeCollapse = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n\n  // Store committed values to avoid unnecessarily re-running memoization/effects functions.\n  const committedValuesRef = useRef({\n    direction,\n    id: groupId,\n    panels,\n    sizes,\n    units\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => groupId,\n    getLayout: unitsFromParams => {\n      const {\n        sizes,\n        units: unitsFromProps\n      } = committedValuesRef.current;\n      const units = unitsFromParams ?? unitsFromProps;\n      if (units === \"pixels\") {\n        const groupSizePixels = getAvailableGroupSizePixels(groupId);\n        return sizes.map(size => size / 100 * groupSizePixels);\n      } else {\n        return sizes;\n      }\n    },\n    setLayout: (sizes, unitsFromParams) => {\n      const {\n        id: groupId,\n        panels,\n        sizes: prevSizes,\n        units\n      } = committedValuesRef.current;\n      if ((unitsFromParams || units) === \"pixels\") {\n        const groupSizePixels = getAvailableGroupSizePixels(groupId);\n        sizes = sizes.map(size => size / groupSizePixels * 100);\n      }\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      const panelsArray = panelsMapToSortedArray(panels);\n      const nextSizes = validatePanelGroupLayout({\n        groupId,\n        panels,\n        nextSizes: sizes,\n        prevSizes,\n        units\n      });\n      if (!areEqual(prevSizes, nextSizes)) {\n        setSizes(nextSizes);\n        callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n      }\n    }\n  }), [groupId]);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.panels = panels;\n    committedValuesRef.current.sizes = sizes;\n    committedValuesRef.current.units = units;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    groupId,\n    panels,\n    setSizes,\n    sizes,\n    panelSizeBeforeCollapse\n  });\n\n  // Notify external code when sizes have changed.\n  useEffect(() => {\n    const {\n      onLayout\n    } = callbacksRef.current;\n    const {\n      panels,\n      sizes\n    } = committedValuesRef.current;\n\n    // Don't commit layout until all panels have registered and re-rendered with their actual sizes.\n    if (sizes.length > 0) {\n      if (onLayout) {\n        onLayout(sizes);\n      }\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n      // When possible, we notify before the next render so that rendering work can be batched together.\n      // Some cases are difficult to detect though,\n      // for example– panels that are conditionally rendered can affect the size of neighboring panels.\n      // In this case, the best we can do is notify on commit.\n      // The callPanelCallbacks() uses its own memoization to avoid notifying panels twice in these cases.\n      const panelsArray = panelsMapToSortedArray(panels);\n      callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, [sizes]);\n\n  // Once all panels have registered themselves,\n  // Compute the initial sizes based on default weights.\n  // This assumes that panels register during initial mount (no conditional rendering)!\n  useIsomorphicLayoutEffect(() => {\n    const {\n      id: groupId,\n      sizes,\n      units\n    } = committedValuesRef.current;\n    if (sizes.length === panels.size) {\n      // Only compute (or restore) default sizes once per panel configuration.\n      return;\n    }\n\n    // If this panel has been configured to persist sizing information,\n    // default size should be restored from local storage if possible.\n    let defaultSizes = null;\n    if (autoSaveId) {\n      const panelsArray = panelsMapToSortedArray(panels);\n      defaultSizes = loadPanelLayout(autoSaveId, panelsArray, storage);\n    }\n    if (defaultSizes != null) {\n      // Validate saved sizes in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const validatedSizes = validatePanelGroupLayout({\n        groupId,\n        panels,\n        nextSizes: defaultSizes,\n        prevSizes: defaultSizes,\n        units\n      });\n      setSizes(validatedSizes);\n    } else {\n      const sizes = calculateDefaultLayout({\n        groupId,\n        panels,\n        units\n      });\n      setSizes(sizes);\n    }\n  }, [autoSaveId, panels, storage]);\n  useEffect(() => {\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (sizes.length === 0 || sizes.length !== panels.size) {\n        return;\n      }\n      const panelsArray = panelsMapToSortedArray(panels);\n\n      // Limit the frequency of localStorage updates.\n      if (!debounceMap[autoSaveId]) {\n        debounceMap[autoSaveId] = debounce(savePanelGroupLayout, 100);\n      }\n      debounceMap[autoSaveId](autoSaveId, panelsArray, sizes, storage);\n    }\n    {\n      const {\n        didLogIdAndOrderWarning,\n        prevPanelIds\n      } = devWarningsRef.current;\n      if (!didLogIdAndOrderWarning) {\n        const {\n          panels\n        } = committedValuesRef.current;\n        const panelIds = Array.from(panels.keys());\n        devWarningsRef.current.prevPanelIds = panelIds;\n        const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n        if (panelsHaveChanged) {\n          if (Array.from(panels.values()).find(panel => panel.current.idWasAutoGenerated || panel.current.order == null)) {\n            devWarningsRef.current.didLogIdAndOrderWarning = true;\n            console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\n          }\n        }\n      }\n    }\n  }, [autoSaveId, panels, sizes, storage]);\n  useIsomorphicLayoutEffect(() => {\n    // Pixel panel constraints need to be reassessed after a group resize\n    // We can avoid the ResizeObserver overhead for relative layouts\n    if (units === \"pixels\") {\n      const resizeObserver = new ResizeObserver(() => {\n        const {\n          panels,\n          sizes: prevSizes\n        } = committedValuesRef.current;\n        const nextSizes = validatePanelGroupLayout({\n          groupId,\n          panels,\n          nextSizes: prevSizes,\n          prevSizes,\n          units\n        });\n        if (!areEqual(prevSizes, nextSizes)) {\n          setSizes(nextSizes);\n        }\n      });\n      resizeObserver.observe(getPanelGroup(groupId));\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n  }, [groupId, units]);\n  const getPanelSize = useCallback((id, unitsFromParams) => {\n    const {\n      panels,\n      units: unitsFromProps\n    } = committedValuesRef.current;\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.findIndex(panel => panel.current.id === id);\n    const size = sizes[index];\n    const units = unitsFromParams ?? unitsFromProps;\n    if (units === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      return size / 100 * groupSizePixels;\n    } else {\n      return size;\n    }\n  }, [groupId, sizes]);\n  const getPanelStyle = useCallback((id, defaultSize) => {\n    const {\n      panels\n    } = committedValuesRef.current;\n\n    // Before mounting, Panels will not yet have registered themselves.\n    // This includes server rendering.\n    // At this point the best we can do is render everything with the same size.\n    if (panels.size === 0) {\n      {\n        if (!devWarningsRef.current.didLogDefaultSizeWarning) ;\n      }\n      return {\n        flexBasis: 0,\n        flexGrow: defaultSize != null ? defaultSize : undefined,\n        flexShrink: 1,\n        // Without this, Panel sizes may be unintentionally overridden by their content.\n        overflow: \"hidden\"\n      };\n    }\n    const flexGrow = getFlexGrow(panels, id, sizes);\n    return {\n      flexBasis: 0,\n      flexGrow,\n      flexShrink: 1,\n      // Without this, Panel sizes may be unintentionally overridden by their content.\n      overflow: \"hidden\",\n      // Disable pointer events inside of a panel during resize.\n      // This avoid edge cases like nested iframes.\n      pointerEvents: disablePointerEventsDuringResize && activeHandleId !== null ? \"none\" : undefined\n    };\n  }, [activeHandleId, disablePointerEventsDuringResize, sizes]);\n  const registerPanel = useCallback((id, panelRef) => {\n    const {\n      units\n    } = committedValuesRef.current;\n    validatePanelProps(units, panelRef);\n    setPanels(prevPanels => {\n      if (prevPanels.has(id)) {\n        return prevPanels;\n      }\n      const nextPanels = new Map(prevPanels);\n      nextPanels.set(id, panelRef);\n      return nextPanels;\n    });\n  }, []);\n  const registerResizeHandle = useCallback(handleId => {\n    const resizeHandler = event => {\n      event.preventDefault();\n      const {\n        direction,\n        panels,\n        sizes: prevSizes\n      } = committedValuesRef.current;\n      const panelsArray = panelsMapToSortedArray(panels);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n      if (idBefore == null || idAfter == null) {\n        return;\n      }\n      let movement = getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragStateRef.current);\n      if (movement === 0) {\n        return;\n      }\n      const groupElement = getPanelGroup(groupId);\n      const rect = groupElement.getBoundingClientRect();\n      const isHorizontal = direction === \"horizontal\";\n\n      // Support RTL layouts\n      if (document.dir === \"rtl\" && isHorizontal) {\n        movement = -movement;\n      }\n      const size = isHorizontal ? rect.width : rect.height;\n      const delta = movement / size * 100;\n\n      // If a validateLayout method has been provided\n      // it's important to use it before updating the mouse cursor\n      const nextSizes = adjustByDelta(event, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, initialDragStateRef.current);\n      const sizesChanged = !areEqual(prevSizes, nextSizes);\n\n      // Don't update cursor for resizes triggered by keyboard interactions.\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change–\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          if (!sizesChanged) {\n            // If the pointer has moved too far to resize the panel any further,\n            // update the cursor style for a visual clue.\n            // This mimics VS Code behavior.\n\n            if (isHorizontal) {\n              setGlobalCursorStyle(movement < 0 ? \"horizontal-min\" : \"horizontal-max\");\n            } else {\n              setGlobalCursorStyle(movement < 0 ? \"vertical-min\" : \"vertical-max\");\n            }\n          } else {\n            // Reset the cursor style to the the normal resize cursor.\n            setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n          }\n        }\n      }\n      if (sizesChanged) {\n        const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n        // It's okay to bypass in this case because we already validated above\n        setSizes(nextSizes);\n\n        // If resize change handlers have been declared, this is the time to call them.\n        // Trigger user callbacks after updating state, so that user code can override the sizes.\n        callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n      }\n      prevDeltaRef.current = delta;\n    };\n    return resizeHandler;\n  }, [groupId]);\n  const unregisterPanel = useCallback(id => {\n    setPanels(prevPanels => {\n      if (!prevPanels.has(id)) {\n        return prevPanels;\n      }\n      const nextPanels = new Map(prevPanels);\n      nextPanels.delete(id);\n      return nextPanels;\n    });\n  }, []);\n  const collapsePanel = useCallback(id => {\n    const {\n      panels,\n      sizes: prevSizes\n    } = committedValuesRef.current;\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    const {\n      collapsedSize,\n      collapsible\n    } = panel.current;\n    if (!collapsible) {\n      return;\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize === collapsedSize) {\n      // Panel is already collapsed.\n      return;\n    }\n    panelSizeBeforeCollapse.current.set(id, currentSize);\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize : collapsedSize - currentSize;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const expandPanel = useCallback(id => {\n    const {\n      panels,\n      sizes: prevSizes\n    } = committedValuesRef.current;\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    const {\n      collapsedSize,\n      minSize\n    } = panel.current;\n    const sizeBeforeCollapse = panelSizeBeforeCollapse.current.get(id) || minSize;\n    if (!sizeBeforeCollapse) {\n      return;\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize !== collapsedSize) {\n      // Panel is already expanded.\n      return;\n    }\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? collapsedSize - sizeBeforeCollapse : sizeBeforeCollapse;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const resizePanel = useCallback((id, nextSize, unitsFromParams) => {\n    const {\n      id: groupId,\n      panels,\n      sizes: prevSizes,\n      units\n    } = committedValuesRef.current;\n    if ((unitsFromParams || units) === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      nextSize = nextSize / groupSizePixels * 100;\n    }\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    let {\n      collapsedSize,\n      collapsible,\n      maxSize,\n      minSize\n    } = panel.current;\n    if (units === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      minSize = minSize / groupSizePixels * 100;\n      if (maxSize != null) {\n        maxSize = maxSize / groupSizePixels * 100;\n      }\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize === nextSize) {\n      return;\n    }\n    if (collapsible && nextSize === collapsedSize) ;else {\n      const unsafeNextSize = nextSize;\n      nextSize = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSize));\n      {\n        if (unsafeNextSize !== nextSize) {\n          console.error(`Invalid size (${unsafeNextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`);\n        }\n      }\n    }\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize - nextSize : nextSize - currentSize;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const context = useMemo(() => ({\n    activeHandleId,\n    collapsePanel,\n    direction,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging: (id, event) => {\n      setActiveHandleId(id);\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        const handleElement = getResizeHandle(id);\n        initialDragStateRef.current = {\n          dragHandleRect: handleElement.getBoundingClientRect(),\n          dragOffset: getDragOffset(event, id, direction),\n          sizes: committedValuesRef.current.sizes\n        };\n      }\n    },\n    stopDragging: () => {\n      resetGlobalCursorStyle();\n      setActiveHandleId(null);\n      initialDragStateRef.current = null;\n    },\n    units,\n    unregisterPanel\n  }), [activeHandleId, collapsePanel, direction, expandPanel, getPanelSize, getPanelStyle, groupId, registerPanel, registerResizeHandle, resizePanel, units, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    children: createElement(Type, {\n      children,\n      className: classNameFromProps,\n      \"data-panel-group\": \"\",\n      \"data-panel-group-direction\": direction,\n      \"data-panel-group-id\": groupId,\n      \"data-panel-group-units\": units,\n      style: {\n        ...style,\n        ...styleFromProps\n      }\n    }),\n    value: context\n  });\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  id: idFromProps = null,\n  onDragging,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const divElementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onDragging\n  });\n  useEffect(() => {\n    callbacksRef.current.onDragging = onDragging;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    activeHandleId,\n    direction,\n    groupId,\n    registerResizeHandle,\n    startDragging,\n    stopDragging\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const isDragging = activeHandleId === resizeHandleId;\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const stopDraggingAndBlur = useCallback(() => {\n    // Clicking on the drag handle shouldn't leave it focused;\n    // That would cause the PanelGroup to think it was still active.\n    const div = divElementRef.current;\n    div.blur();\n    stopDragging();\n    const {\n      onDragging\n    } = callbacksRef.current;\n    if (onDragging) {\n      onDragging(false);\n    }\n  }, [stopDragging]);\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandle(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandle]);\n  useEffect(() => {\n    if (disabled || resizeHandler == null || !isDragging) {\n      return;\n    }\n    const onMove = event => {\n      resizeHandler(event);\n    };\n    const onMouseLeave = event => {\n      resizeHandler(event);\n    };\n    const divElement = divElementRef.current;\n    const targetDocument = divElement.ownerDocument;\n    targetDocument.body.addEventListener(\"contextmenu\", stopDraggingAndBlur);\n    targetDocument.body.addEventListener(\"mousemove\", onMove);\n    targetDocument.body.addEventListener(\"touchmove\", onMove);\n    targetDocument.body.addEventListener(\"mouseleave\", onMouseLeave);\n    window.addEventListener(\"mouseup\", stopDraggingAndBlur);\n    window.addEventListener(\"touchend\", stopDraggingAndBlur);\n    return () => {\n      targetDocument.body.removeEventListener(\"contextmenu\", stopDraggingAndBlur);\n      targetDocument.body.removeEventListener(\"mousemove\", onMove);\n      targetDocument.body.removeEventListener(\"touchmove\", onMove);\n      targetDocument.body.removeEventListener(\"mouseleave\", onMouseLeave);\n      window.removeEventListener(\"mouseup\", stopDraggingAndBlur);\n      window.removeEventListener(\"touchend\", stopDraggingAndBlur);\n    };\n  }, [direction, disabled, isDragging, resizeHandler, stopDraggingAndBlur]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler\n  });\n  const style = {\n    cursor: getCursorStyle(direction),\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-resize-handle-active\": isDragging ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId,\n    onBlur: () => setIsFocused(false),\n    onFocus: () => setIsFocused(true),\n    onMouseDown: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    onMouseUp: stopDraggingAndBlur,\n    onTouchCancel: stopDraggingAndBlur,\n    onTouchEnd: stopDraggingAndBlur,\n    onTouchStart: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    ref: divElementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex: 0\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\nexport { Panel, PanelGroup, PanelResizeHandle, getAvailableGroupSizePixels };","map":{"version":3,"names":["React","createElement","createContext","forwardRef","useCallback","useContext","useEffect","useImperativeHandle","useLayoutEffect","useMemo","useRef","useState","useId","toString","useIsomorphicLayoutEffect","wrappedUseId","counter","useUniqueId","idFromParams","idFromUseId","idRef","current","PanelGroupContext","displayName","PanelWithForwardedRef","children","className","classNameFromProps","collapsedSize","collapsible","defaultSize","forwardedRef","id","idFromProps","maxSize","minSize","onCollapse","onResize","order","style","styleFromProps","tagName","Type","context","Error","panelId","collapsePanel","expandPanel","getPanelSize","getPanelStyle","registerPanel","resizePanel","units","unregisterPanel","callbacksRef","committedValuesRef","size","parseSizeFromStyle","panelDataRef","idWasAutoGenerated","collapse","expand","getCollapsed","getId","getSize","resize","percentage","undefined","parseFloat","flexGrow","toFixed","Panel","props","ref","PRECISION","adjustByDelta","event","committedValues","idBefore","idAfter","deltaPixels","prevSizes","panelSizeBeforeCollapse","initialDragState","groupId","panels","groupSizePixels","getAvailableGroupSizePixels","NaN","sizes","initialSizes","baseSizes","panelsArray","panelsMapToSortedArray","nextSizes","concat","deltaApplied","pivotId","index","findIndex","panel","baseSize","nextSize","safeResizePanel","Math","abs","set","deltaRemaining","toPrecision","localeCompare","numeric","length","callPanelCallbacks","panelIdToLastNotifiedSizeMap","forEach","panelRef","lastNotifiedSize","calculateDefaultLayout","Array","numPanelsWithSizes","remainingSize","remainingPanels","min","max","console","error","getBeforeAndAfterIds","isLastPanel","panelGroupElement","getPanelGroup","direction","getAttribute","resizeHandles","getResizeHandlesForGroup","offsetWidth","reduce","accumulated","handle","offsetHeight","getFlexGrow","getPanel","element","document","querySelector","getResizeHandle","getResizeHandleIndex","handles","getResizeHandles","from","querySelectorAll","getResizeHandlePanelIds","handleId","indexOf","values","sort","panelA","panelB","orderA","orderB","prevSize","isKeyboardEvent","type","startsWith","validatePanelProps","panelData","validatePanelGroupLayout","safeNextSize","assert","expectedCondition","message","useWindowSplitterPanelGroupBehavior","setSizes","groupElement","height","width","getBoundingClientRect","cleanupFunctions","map","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","ariaValueMax","ariaValueMin","setAttribute","round","parseInt","onKeyDown","defaultPrevented","key","preventDefault","delta","addEventListener","panelBefore","removeAttribute","removeEventListener","cleanupFunction","useWindowSplitterResizeHandlerBehavior","disabled","resizeHandler","handleElement","nextIndex","shiftKey","nextHandle","focus","areEqual","arrayA","arrayB","getDragOffset","initialOffset","initialHandleElementRect","isHorizontal","pointerOffset","isMouseEvent","clientX","clientY","isTouchEvent","firstTouch","touches","screenX","screenY","rect","elementOffset","left","top","getMovement","dragOffset","dragHandleRect","isKeyDown","groupSizeInPixels","denominator","movement","targetPanelId","targetPanelIndex","targetPanel","currentState","getCursorStyle","state","resetGlobalCursorStyle","head","removeChild","setGlobalCursorStyle","appendChild","innerHTML","debounce","callback","durationMs","timeoutId","callable","args","clearTimeout","setTimeout","getSerializationKey","a","b","join","loadSerializedPanelGroupState","autoSaveId","storage","serialized","getItem","parsed","JSON","parse","loadPanelLayout","savePanelGroupLayout","setItem","stringify","debounceMap","initializeDefaultStorage","storageObject","localStorage","name","value","defaultStorage","PanelGroupWithForwardedRef","disablePointerEventsDuringResize","onLayout","activeHandleId","setActiveHandleId","setPanels","Map","initialDragStateRef","devWarningsRef","didLogDefaultSizeWarning","didLogIdAndOrderWarning","didLogInvalidLayoutWarning","prevPanelIds","panelIdToLastNotifiedSizeMapRef","prevDeltaRef","getLayout","unitsFromParams","unitsFromProps","setLayout","defaultSizes","validatedSizes","panelIds","keys","panelsHaveChanged","find","warn","resizeObserver","ResizeObserver","observe","disconnect","flexBasis","flexShrink","overflow","pointerEvents","prevPanels","has","nextPanels","registerResizeHandle","dir","sizesChanged","delete","get","currentSize","sizeBeforeCollapse","unsafeNextSize","startDragging","stopDragging","display","flexDirection","Provider","PanelGroup","PanelResizeHandle","onDragging","divElementRef","panelGroupContext","resizeHandleId","isDragging","isFocused","setIsFocused","setResizeHandler","stopDraggingAndBlur","div","blur","onMove","onMouseLeave","divElement","targetDocument","ownerDocument","body","window","cursor","touchAction","userSelect","onBlur","onFocus","onMouseDown","nativeEvent","onMouseUp","onTouchCancel","onTouchEnd","onTouchStart","role","tabIndex"],"sources":["/home/zain/HTN2023/node_modules/react-resizable-panels/dist/react-resizable-panels.browser.development.esm.js"],"sourcesContent":["import * as React from 'react';\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n\n// eslint-disable-next-line no-restricted-imports\n\nconst {\n  createElement,\n  createContext,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState\n} = React;\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = React[\"useId\".toString()];\n\nconst useIsomorphicLayoutEffect = useLayoutEffect ;\n\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idRef.current;\n}\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nfunction PanelWithForwardedRef({\n  children = null,\n  className: classNameFromProps = \"\",\n  collapsedSize = 0,\n  collapsible = false,\n  defaultSize = null,\n  forwardedRef,\n  id: idFromProps = null,\n  maxSize = null,\n  minSize,\n  onCollapse = null,\n  onResize = null,\n  order = null,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const panelId = useUniqueId(idFromProps);\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    registerPanel,\n    resizePanel,\n    units,\n    unregisterPanel\n  } = context;\n  if (minSize == null) {\n    if (units === \"percentages\") {\n      // Mimics legacy default value for percentage based panel groups\n      minSize = 10;\n    } else {\n      // There is no meaningful minimum pixel default we can provide\n      minSize = 0;\n    }\n  }\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onCollapse,\n    onResize\n  });\n  useEffect(() => {\n    callbacksRef.current.onCollapse = onCollapse;\n    callbacksRef.current.onResize = onResize;\n  });\n  const style = getPanelStyle(panelId, defaultSize);\n  const committedValuesRef = useRef({\n    size: parseSizeFromStyle(style)\n  });\n  const panelDataRef = useRef({\n    callbacksRef,\n    collapsedSize,\n    collapsible,\n    defaultSize,\n    id: panelId,\n    idWasAutoGenerated: idFromProps == null,\n    maxSize,\n    minSize,\n    order\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.size = parseSizeFromStyle(style);\n    panelDataRef.current.callbacksRef = callbacksRef;\n    panelDataRef.current.collapsedSize = collapsedSize;\n    panelDataRef.current.collapsible = collapsible;\n    panelDataRef.current.defaultSize = defaultSize;\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idWasAutoGenerated = idFromProps == null;\n    panelDataRef.current.maxSize = maxSize;\n    panelDataRef.current.minSize = minSize;\n    panelDataRef.current.order = order;\n  });\n  useIsomorphicLayoutEffect(() => {\n    registerPanel(panelId, panelDataRef);\n    return () => {\n      unregisterPanel(panelId);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => collapsePanel(panelId),\n    expand: () => expandPanel(panelId),\n    getCollapsed() {\n      return committedValuesRef.current.size === 0;\n    },\n    getId() {\n      return panelId;\n    },\n    getSize(units) {\n      return getPanelSize(panelId, units);\n    },\n    resize: (percentage, units) => resizePanel(panelId, percentage, units)\n  }), [collapsePanel, expandPanel, getPanelSize, panelId, resizePanel]);\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-panel\": \"\",\n    \"data-panel-collapsible\": collapsible || undefined,\n    \"data-panel-id\": panelId,\n    \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1),\n    id: `data-panel-id-${panelId}`,\n    style: {\n      ...style,\n      ...styleFromProps\n    }\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\n// HACK\nfunction parseSizeFromStyle(style) {\n  const {\n    flexGrow\n  } = style;\n  if (typeof flexGrow === \"string\") {\n    return parseFloat(flexGrow);\n  } else {\n    return flexGrow;\n  }\n}\n\nconst PRECISION = 10;\n\nfunction adjustByDelta(event, committedValues, idBefore, idAfter, deltaPixels, prevSizes, panelSizeBeforeCollapse, initialDragState) {\n  const {\n    id: groupId,\n    panels,\n    units\n  } = committedValues;\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  const {\n    sizes: initialSizes\n  } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n  const panelsArray = panelsMapToSortedArray(panels);\n  const nextSizes = baseSizes.concat();\n  let deltaApplied = 0;\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel immediately after the resizer should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel immediately before the resizer should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resizer.\n\n  // Max-bounds check the panel being expanded first.\n  {\n    const pivotId = deltaPixels < 0 ? idAfter : idBefore;\n    const index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n    const nextSize = safeResizePanel(units, groupSizePixels, panel, baseSize, baseSize + Math.abs(deltaPixels), event);\n    if (baseSize === nextSize) {\n      // If there's no room for the pivot panel to grow, we can ignore this drag update.\n      return baseSizes;\n    } else {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(pivotId, baseSize);\n      }\n      deltaPixels = deltaPixels < 0 ? baseSize - nextSize : nextSize - baseSize;\n    }\n  }\n  let pivotId = deltaPixels < 0 ? idBefore : idAfter;\n  let index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n  while (true) {\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n    const deltaRemaining = Math.abs(deltaPixels) - Math.abs(deltaApplied);\n    const nextSize = safeResizePanel(units, groupSizePixels, panel, baseSize, baseSize - deltaRemaining, event);\n    if (baseSize !== nextSize) {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(panel.current.id, baseSize);\n      }\n      deltaApplied += baseSize - nextSize;\n      nextSizes[index] = nextSize;\n      if (deltaApplied.toPrecision(PRECISION).localeCompare(Math.abs(deltaPixels).toPrecision(PRECISION), undefined, {\n        numeric: true\n      }) >= 0) {\n        break;\n      }\n    }\n    if (deltaPixels < 0) {\n      if (--index < 0) {\n        break;\n      }\n    } else {\n      if (++index >= panelsArray.length) {\n        break;\n      }\n    }\n  }\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore the \"mousemove\" event.\n  if (deltaApplied === 0) {\n    return baseSizes;\n  }\n\n  // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n  pivotId = deltaPixels < 0 ? idAfter : idBefore;\n  index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n  nextSizes[index] = baseSizes[index] + deltaApplied;\n  return nextSizes;\n}\nfunction callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap) {\n  sizes.forEach((size, index) => {\n    const panelRef = panelsArray[index];\n    if (!panelRef) {\n      // Handle initial mount (when panels are registered too late to be in the panels array)\n      // The subsequent render+effects will handle the resize notification\n      return;\n    }\n    const {\n      callbacksRef,\n      collapsedSize,\n      collapsible,\n      id\n    } = panelRef.current;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[id];\n    if (lastNotifiedSize !== size) {\n      panelIdToLastNotifiedSizeMap[id] = size;\n      const {\n        onCollapse,\n        onResize\n      } = callbacksRef.current;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && onCollapse) {\n        if ((lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size !== collapsedSize) {\n          onCollapse(false);\n        } else if (lastNotifiedSize !== collapsedSize && size === collapsedSize) {\n          onCollapse(true);\n        }\n      }\n    }\n  });\n}\nfunction calculateDefaultLayout({\n  groupId,\n  panels,\n  units\n}) {\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  const panelsArray = panelsMapToSortedArray(panels);\n  const sizes = Array(panelsArray.length);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Assigning default sizes requires a couple of passes:\n  // First, all panels with defaultSize should be set as-is\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    const {\n      defaultSize\n    } = panel.current;\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      sizes[index] = units === \"pixels\" ? defaultSize / groupSizePixels * 100 : defaultSize;\n      remainingSize -= sizes[index];\n    }\n  }\n\n  // Remaining total size should be distributed evenly between panels\n  // This may require two passes, depending on min/max constraints\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    let {\n      defaultSize,\n      id,\n      maxSize,\n      minSize\n    } = panel.current;\n    if (defaultSize != null) {\n      continue;\n    }\n    if (units === \"pixels\") {\n      minSize = minSize / groupSizePixels * 100;\n      if (maxSize != null) {\n        maxSize = maxSize / groupSizePixels * 100;\n      }\n    }\n    const remainingPanels = panelsArray.length - numPanelsWithSizes;\n    const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, remainingSize / remainingPanels));\n    sizes[index] = size;\n    numPanelsWithSizes++;\n    remainingSize -= size;\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (remainingSize !== 0) {\n    for (let index = 0; index < panelsArray.length; index++) {\n      const panel = panelsArray[index];\n      let {\n        maxSize,\n        minSize\n      } = panel.current;\n      if (units === \"pixels\") {\n        minSize = minSize / groupSizePixels * 100;\n        if (maxSize != null) {\n          maxSize = maxSize / groupSizePixels * 100;\n        }\n      }\n      const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, sizes[index] + remainingSize));\n      if (size !== sizes[index]) {\n        remainingSize -= size - sizes[index];\n        sizes[index] = size;\n\n        // Fuzzy comparison to account for imprecise floating point math\n        if (Math.abs(remainingSize).toFixed(3) === \"0.000\") {\n          break;\n        }\n      }\n    }\n  }\n\n  // Finally, if there is still left-over size, log an error\n  if (Math.abs(remainingSize).toFixed(3) !== \"0.000\") {\n    {\n      console.error(`Invalid panel group configuration; default panel sizes should total 100% but was ${(100 - remainingSize).toFixed(1)}%. This can cause the cursor to become misaligned while dragging.`);\n    }\n  }\n  return sizes;\n}\nfunction getBeforeAndAfterIds(id, panelsArray) {\n  if (panelsArray.length < 2) {\n    return [null, null];\n  }\n  const index = panelsArray.findIndex(panel => panel.current.id === id);\n  if (index < 0) {\n    return [null, null];\n  }\n  const isLastPanel = index === panelsArray.length - 1;\n  const idBefore = isLastPanel ? panelsArray[index - 1].current.id : id;\n  const idAfter = isLastPanel ? id : panelsArray[index + 1].current.id;\n  return [idBefore, idAfter];\n}\nfunction getAvailableGroupSizePixels(groupId) {\n  const panelGroupElement = getPanelGroup(groupId);\n  if (panelGroupElement == null) {\n    return NaN;\n  }\n  const direction = panelGroupElement.getAttribute(\"data-panel-group-direction\");\n  const resizeHandles = getResizeHandlesForGroup(groupId);\n  if (direction === \"horizontal\") {\n    return panelGroupElement.offsetWidth - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetWidth;\n    }, 0);\n  } else {\n    return panelGroupElement.offsetHeight - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetHeight;\n    }, 0);\n  }\n}\n\n// This method returns a number between 1 and 100 representing\n// the % of the group's overall space this panel should occupy.\nfunction getFlexGrow(panels, id, sizes) {\n  if (panels.size === 1) {\n    return \"100\";\n  }\n  const panelsArray = panelsMapToSortedArray(panels);\n  const index = panelsArray.findIndex(panel => panel.current.id === id);\n  const size = sizes[index];\n  if (size == null) {\n    return \"0\";\n  }\n  return size.toPrecision(PRECISION);\n}\nfunction getPanel(id) {\n  const element = document.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getPanelGroup(id) {\n  const element = document.querySelector(`[data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandle(id) {\n  const element = document.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandleIndex(id) {\n  const handles = getResizeHandles();\n  const index = handles.findIndex(handle => handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n  return index ?? null;\n}\nfunction getResizeHandles() {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id]`));\n}\nfunction getResizeHandlesForGroup(groupId) {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray) {\n  const handle = getResizeHandle(handleId);\n  const handles = getResizeHandlesForGroup(groupId);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = panelsArray[index]?.current?.id ?? null;\n  const idAfter = panelsArray[index + 1]?.current?.id ?? null;\n  return [idBefore, idAfter];\n}\nfunction panelsMapToSortedArray(panels) {\n  return Array.from(panels.values()).sort((panelA, panelB) => {\n    const orderA = panelA.current.order;\n    const orderB = panelB.current.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction safeResizePanel(units, groupSizePixels, panel, prevSize, nextSize, event = null) {\n  let {\n    collapsedSize,\n    collapsible,\n    maxSize,\n    minSize\n  } = panel.current;\n  if (units === \"pixels\") {\n    collapsedSize = collapsedSize / groupSizePixels * 100;\n    if (maxSize != null) {\n      maxSize = maxSize / groupSizePixels * 100;\n    }\n    minSize = minSize / groupSizePixels * 100;\n  }\n  if (collapsible) {\n    if (prevSize > collapsedSize) {\n      // Mimic VS COde behavior; collapse a panel if it's smaller than half of its min-size\n      if (nextSize <= minSize / 2 + collapsedSize) {\n        return collapsedSize;\n      }\n    } else {\n      const isKeyboardEvent = event?.type?.startsWith(\"key\");\n      if (!isKeyboardEvent) {\n        // Keyboard events should expand a collapsed panel to the min size,\n        // but mouse events should wait until the panel has reached its min size\n        // to avoid a visual flickering when dragging between collapsed and min size.\n        if (nextSize < minSize) {\n          return collapsedSize;\n        }\n      }\n    }\n  }\n  return Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSize));\n}\nfunction validatePanelProps(units, panelData) {\n  const {\n    collapsible,\n    defaultSize,\n    maxSize,\n    minSize\n  } = panelData.current;\n\n  // Basic props validation\n  if (minSize < 0 || units === \"percentages\" && minSize > 100) {\n    {\n      console.error(`Invalid Panel minSize provided, ${minSize}`);\n    }\n    panelData.current.minSize = 0;\n  }\n  if (maxSize != null) {\n    if (maxSize < 0 || units === \"percentages\" && maxSize > 100) {\n      {\n        console.error(`Invalid Panel maxSize provided, ${maxSize}`);\n      }\n      panelData.current.maxSize = null;\n    }\n  }\n  if (defaultSize !== null) {\n    if (defaultSize < 0 || units === \"percentages\" && defaultSize > 100) {\n      {\n        console.error(`Invalid Panel defaultSize provided, ${defaultSize}`);\n      }\n      panelData.current.defaultSize = null;\n    } else if (defaultSize < minSize && !collapsible) {\n      {\n        console.error(`Panel minSize (${minSize}) cannot be greater than defaultSize (${defaultSize})`);\n      }\n      panelData.current.defaultSize = minSize;\n    } else if (maxSize != null && defaultSize > maxSize) {\n      {\n        console.error(`Panel maxSize (${maxSize}) cannot be less than defaultSize (${defaultSize})`);\n      }\n      panelData.current.defaultSize = maxSize;\n    }\n  }\n}\nfunction validatePanelGroupLayout({\n  groupId,\n  panels,\n  nextSizes,\n  prevSizes,\n  units\n}) {\n  // Clone because this method modifies\n  nextSizes = [...nextSizes];\n  const panelsArray = panelsMapToSortedArray(panels);\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  let remainingSize = 0;\n\n  // First, check all of the proposed sizes against the min/max constraints\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    const prevSize = prevSizes[index];\n    const nextSize = nextSizes[index];\n    const safeNextSize = safeResizePanel(units, groupSizePixels, panel, prevSize, nextSize);\n    if (nextSize != safeNextSize) {\n      remainingSize += nextSize - safeNextSize;\n      nextSizes[index] = safeNextSize;\n      {\n        console.error(`Invalid size (${nextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`);\n      }\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (remainingSize.toFixed(3) !== \"0.000\") {\n    for (let index = 0; index < panelsArray.length; index++) {\n      const panel = panelsArray[index];\n      let {\n        maxSize,\n        minSize\n      } = panel.current;\n      if (units === \"pixels\") {\n        minSize = minSize / groupSizePixels * 100;\n        if (maxSize != null) {\n          maxSize = maxSize / groupSizePixels * 100;\n        }\n      }\n      const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSizes[index] + remainingSize));\n      if (size !== nextSizes[index]) {\n        remainingSize -= size - nextSizes[index];\n        nextSizes[index] = size;\n\n        // Fuzzy comparison to account for imprecise floating point math\n        if (Math.abs(remainingSize).toFixed(3) === \"0.000\") {\n          break;\n        }\n      }\n    }\n  }\n\n  // If we still have remainder, the requested layout wasn't valid and we should warn about it\n  if (remainingSize.toFixed(3) !== \"0.000\") {\n    {\n      console.error(`\"Invalid panel group configuration; default panel sizes should total 100% but was ${100 - remainingSize}%`);\n    }\n  }\n  return nextSizes;\n}\n\nfunction assert(expectedCondition, message = \"Assertion failed!\") {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  groupId,\n  panels,\n  setSizes,\n  sizes,\n  panelSizeBeforeCollapse\n}) {\n  useEffect(() => {\n    const {\n      direction,\n      panels\n    } = committedValuesRef.current;\n    const groupElement = getPanelGroup(groupId);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const {\n      height,\n      width\n    } = groupElement.getBoundingClientRect();\n    const handles = getResizeHandlesForGroup(groupId);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n      const panelsArray = panelsMapToSortedArray(panels);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      let currentMinSize = 0;\n      let currentMaxSize = 100;\n      let totalMinSize = 0;\n      let totalMaxSize = 0;\n\n      // A panel's effective min/max sizes also need to account for other panel's sizes.\n      panelsArray.forEach(panelData => {\n        const {\n          id,\n          maxSize,\n          minSize\n        } = panelData.current;\n        if (id === idBefore) {\n          currentMinSize = minSize;\n          currentMaxSize = maxSize != null ? maxSize : 100;\n        } else {\n          totalMinSize += minSize;\n          totalMaxSize += maxSize != null ? maxSize : 100;\n        }\n      });\n      const ariaValueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n      const ariaValueMin = Math.max(currentMinSize, (panelsArray.length - 1) * 100 - totalMaxSize);\n      const flexGrow = getFlexGrow(panels, idBefore, sizes);\n      handle.setAttribute(\"aria-valuemax\", \"\" + Math.round(ariaValueMax));\n      handle.setAttribute(\"aria-valuemin\", \"\" + Math.round(ariaValueMin));\n      handle.setAttribute(\"aria-valuenow\", \"\" + Math.round(parseInt(flexGrow)));\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelsArray.findIndex(panel => panel.current.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelsArray[index];\n                const size = sizes[index];\n                if (size != null) {\n                  let delta = 0;\n                  if (size.toPrecision(PRECISION) <= panelData.current.minSize.toPrecision(PRECISION)) {\n                    delta = direction === \"horizontal\" ? width : height;\n                  } else {\n                    delta = -(direction === \"horizontal\" ? width : height);\n                  }\n                  const nextSizes = adjustByDelta(event, committedValuesRef.current, idBefore, idAfter, delta, sizes, panelSizeBeforeCollapse.current, null);\n                  if (sizes !== nextSizes) {\n                    setSizes(nextSizes);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      const panelBefore = getPanel(idBefore);\n      if (panelBefore != null) {\n        handle.setAttribute(\"aria-controls\", panelBefore.id);\n      }\n      return () => {\n        handle.removeAttribute(\"aria-valuemax\");\n        handle.removeAttribute(\"aria-valuemin\");\n        handle.removeAttribute(\"aria-valuenow\");\n        handle.removeEventListener(\"keydown\", onKeyDown);\n        if (panelBefore != null) {\n          handle.removeAttribute(\"aria-controls\");\n        }\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [committedValuesRef, groupId, panels, panelSizeBeforeCollapse, setSizes, sizes]);\n}\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const handleElement = getResizeHandle(handleId);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const handles = getResizeHandles();\n            const index = getResizeHandleIndex(handleId);\n            assert(index !== null);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [disabled, handleId, resizeHandler]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getDragOffset(event, handleId, direction, initialOffset = 0, initialHandleElementRect = null) {\n  const isHorizontal = direction === \"horizontal\";\n  let pointerOffset = 0;\n  if (isMouseEvent(event)) {\n    pointerOffset = isHorizontal ? event.clientX : event.clientY;\n  } else if (isTouchEvent(event)) {\n    const firstTouch = event.touches[0];\n    pointerOffset = isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n  } else {\n    return 0;\n  }\n  const handleElement = getResizeHandle(handleId);\n  const rect = initialHandleElementRect || handleElement.getBoundingClientRect();\n  const elementOffset = isHorizontal ? rect.left : rect.top;\n  return pointerOffset - elementOffset - initialOffset;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragState) {\n  const {\n    dragOffset = 0,\n    dragHandleRect,\n    sizes: initialSizes\n  } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    const groupElement = getPanelGroup(groupId);\n    const rect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? rect.width : rect.height;\n    const denominator = event.shiftKey ? 10 : 100;\n    const delta = groupSizeInPixels / denominator;\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = groupSizeInPixels;\n        break;\n      case \"Home\":\n        movement = -groupSizeInPixels;\n        break;\n    }\n\n    // If the Panel being resized is collapsible,\n    // we need to special case resizing around the minSize boundary.\n    // If contracting, Panels should shrink to their minSize and then snap to fully collapsed.\n    // If expanding from collapsed, they should snap back to their minSize.\n    const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n    const targetPanelId = movement < 0 ? idBefore : idAfter;\n    const targetPanelIndex = panelsArray.findIndex(panel => panel.current.id === targetPanelId);\n    const targetPanel = panelsArray[targetPanelIndex];\n    if (targetPanel.current.collapsible) {\n      const baseSize = baseSizes[targetPanelIndex];\n      if (baseSize === 0 || baseSize.toPrecision(PRECISION) === targetPanel.current.minSize.toPrecision(PRECISION)) {\n        movement = movement < 0 ? -targetPanel.current.minSize * groupSizeInPixels : targetPanel.current.minSize * groupSizeInPixels;\n      }\n    }\n    return movement;\n  } else {\n    return getDragOffset(event, handleId, direction, dragOffset, dragHandleRect);\n  }\n}\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\nfunction isTouchEvent(event) {\n  return event.type.startsWith(\"touch\");\n}\n\nlet currentState = null;\nlet element = null;\nfunction getCursorStyle(state) {\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"horizontal-max\":\n      return \"w-resize\";\n    case \"horizontal-min\":\n      return \"e-resize\";\n    case \"vertical\":\n      return \"ns-resize\";\n    case \"vertical-max\":\n      return \"n-resize\";\n    case \"vertical-min\":\n      return \"s-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (element !== null) {\n    document.head.removeChild(element);\n    currentState = null;\n    element = null;\n  }\n}\nfunction setGlobalCursorStyle(state) {\n  if (currentState === state) {\n    return;\n  }\n  currentState = state;\n  const style = getCursorStyle(state);\n  if (element === null) {\n    element = document.createElement(\"style\");\n    document.head.appendChild(element);\n  }\n  element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using an attribute like minSize instead should work well enough.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getSerializationKey(panels) {\n  return panels.map(panel => {\n    const {\n      minSize,\n      order\n    } = panel.current;\n    return order ? `${order}:${minSize}` : `${minSize}`;\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const serialized = storage.getItem(`PanelGroup:sizes:${autoSaveId}`);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelLayout(autoSaveId, panels, storage) {\n  const state = loadSerializedPanelGroupState(autoSaveId, storage);\n  if (state) {\n    const key = getSerializationKey(panels);\n    return state[key] ?? null;\n  }\n  return null;\n}\nfunction savePanelGroupLayout(autoSaveId, panels, sizes, storage) {\n  const key = getSerializationKey(panels);\n  const state = loadSerializedPanelGroupState(autoSaveId, storage) || {};\n  state[key] = sizes;\n  try {\n    storage.setItem(`PanelGroup:sizes:${autoSaveId}`, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nconst debounceMap = {};\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\n\n// Initial drag state serves a few purposes:\n// * dragOffset:\n//   Resize is calculated by the distance between the current pointer event and the resize handle being \"dragged\"\n//   This value accounts for the initial offset when the touch/click starts, so the handle doesn't appear to \"jump\"\n// * dragHandleRect, sizes:\n//   When resizing is done via mouse/touch event– some initial state is stored\n//   so that any panels that contract will also expand if drag direction is reversed.\nfunction PanelGroupWithForwardedRef({\n  autoSaveId,\n  children = null,\n  className: classNameFromProps = \"\",\n  direction,\n  disablePointerEventsDuringResize = false,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout,\n  storage = defaultStorage,\n  style: styleFromProps = {},\n  tagName: Type = \"div\",\n  units = \"percentages\"\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const [activeHandleId, setActiveHandleId] = useState(null);\n  const [panels, setPanels] = useState(new Map());\n\n  // When resizing is done via mouse/touch event–\n  // We store the initial Panel sizes in this ref, and apply move deltas to them instead of to the current sizes.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const initialDragStateRef = useRef(null);\n  const devWarningsRef = useRef({\n    didLogDefaultSizeWarning: false,\n    didLogIdAndOrderWarning: false,\n    didLogInvalidLayoutWarning: false,\n    prevPanelIds: []\n  });\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onLayout\n  });\n  useEffect(() => {\n    callbacksRef.current.onLayout = onLayout;\n  });\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n\n  // 0-1 values representing the relative size of each panel.\n  const [sizes, setSizes] = useState([]);\n\n  // Used to support imperative collapse/expand API.\n  const panelSizeBeforeCollapse = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n\n  // Store committed values to avoid unnecessarily re-running memoization/effects functions.\n  const committedValuesRef = useRef({\n    direction,\n    id: groupId,\n    panels,\n    sizes,\n    units\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => groupId,\n    getLayout: unitsFromParams => {\n      const {\n        sizes,\n        units: unitsFromProps\n      } = committedValuesRef.current;\n      const units = unitsFromParams ?? unitsFromProps;\n      if (units === \"pixels\") {\n        const groupSizePixels = getAvailableGroupSizePixels(groupId);\n        return sizes.map(size => size / 100 * groupSizePixels);\n      } else {\n        return sizes;\n      }\n    },\n    setLayout: (sizes, unitsFromParams) => {\n      const {\n        id: groupId,\n        panels,\n        sizes: prevSizes,\n        units\n      } = committedValuesRef.current;\n      if ((unitsFromParams || units) === \"pixels\") {\n        const groupSizePixels = getAvailableGroupSizePixels(groupId);\n        sizes = sizes.map(size => size / groupSizePixels * 100);\n      }\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      const panelsArray = panelsMapToSortedArray(panels);\n      const nextSizes = validatePanelGroupLayout({\n        groupId,\n        panels,\n        nextSizes: sizes,\n        prevSizes,\n        units\n      });\n      if (!areEqual(prevSizes, nextSizes)) {\n        setSizes(nextSizes);\n        callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n      }\n    }\n  }), [groupId]);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.panels = panels;\n    committedValuesRef.current.sizes = sizes;\n    committedValuesRef.current.units = units;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    groupId,\n    panels,\n    setSizes,\n    sizes,\n    panelSizeBeforeCollapse\n  });\n\n  // Notify external code when sizes have changed.\n  useEffect(() => {\n    const {\n      onLayout\n    } = callbacksRef.current;\n    const {\n      panels,\n      sizes\n    } = committedValuesRef.current;\n\n    // Don't commit layout until all panels have registered and re-rendered with their actual sizes.\n    if (sizes.length > 0) {\n      if (onLayout) {\n        onLayout(sizes);\n      }\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n      // When possible, we notify before the next render so that rendering work can be batched together.\n      // Some cases are difficult to detect though,\n      // for example– panels that are conditionally rendered can affect the size of neighboring panels.\n      // In this case, the best we can do is notify on commit.\n      // The callPanelCallbacks() uses its own memoization to avoid notifying panels twice in these cases.\n      const panelsArray = panelsMapToSortedArray(panels);\n      callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, [sizes]);\n\n  // Once all panels have registered themselves,\n  // Compute the initial sizes based on default weights.\n  // This assumes that panels register during initial mount (no conditional rendering)!\n  useIsomorphicLayoutEffect(() => {\n    const {\n      id: groupId,\n      sizes,\n      units\n    } = committedValuesRef.current;\n    if (sizes.length === panels.size) {\n      // Only compute (or restore) default sizes once per panel configuration.\n      return;\n    }\n\n    // If this panel has been configured to persist sizing information,\n    // default size should be restored from local storage if possible.\n    let defaultSizes = null;\n    if (autoSaveId) {\n      const panelsArray = panelsMapToSortedArray(panels);\n      defaultSizes = loadPanelLayout(autoSaveId, panelsArray, storage);\n    }\n    if (defaultSizes != null) {\n      // Validate saved sizes in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const validatedSizes = validatePanelGroupLayout({\n        groupId,\n        panels,\n        nextSizes: defaultSizes,\n        prevSizes: defaultSizes,\n        units\n      });\n      setSizes(validatedSizes);\n    } else {\n      const sizes = calculateDefaultLayout({\n        groupId,\n        panels,\n        units\n      });\n      setSizes(sizes);\n    }\n  }, [autoSaveId, panels, storage]);\n  useEffect(() => {\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (sizes.length === 0 || sizes.length !== panels.size) {\n        return;\n      }\n      const panelsArray = panelsMapToSortedArray(panels);\n\n      // Limit the frequency of localStorage updates.\n      if (!debounceMap[autoSaveId]) {\n        debounceMap[autoSaveId] = debounce(savePanelGroupLayout, 100);\n      }\n      debounceMap[autoSaveId](autoSaveId, panelsArray, sizes, storage);\n    }\n    {\n      const {\n        didLogIdAndOrderWarning,\n        prevPanelIds\n      } = devWarningsRef.current;\n      if (!didLogIdAndOrderWarning) {\n        const {\n          panels\n        } = committedValuesRef.current;\n        const panelIds = Array.from(panels.keys());\n        devWarningsRef.current.prevPanelIds = panelIds;\n        const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n        if (panelsHaveChanged) {\n          if (Array.from(panels.values()).find(panel => panel.current.idWasAutoGenerated || panel.current.order == null)) {\n            devWarningsRef.current.didLogIdAndOrderWarning = true;\n            console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\n          }\n        }\n      }\n    }\n  }, [autoSaveId, panels, sizes, storage]);\n  useIsomorphicLayoutEffect(() => {\n    // Pixel panel constraints need to be reassessed after a group resize\n    // We can avoid the ResizeObserver overhead for relative layouts\n    if (units === \"pixels\") {\n      const resizeObserver = new ResizeObserver(() => {\n        const {\n          panels,\n          sizes: prevSizes\n        } = committedValuesRef.current;\n        const nextSizes = validatePanelGroupLayout({\n          groupId,\n          panels,\n          nextSizes: prevSizes,\n          prevSizes,\n          units\n        });\n        if (!areEqual(prevSizes, nextSizes)) {\n          setSizes(nextSizes);\n        }\n      });\n      resizeObserver.observe(getPanelGroup(groupId));\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n  }, [groupId, units]);\n  const getPanelSize = useCallback((id, unitsFromParams) => {\n    const {\n      panels,\n      units: unitsFromProps\n    } = committedValuesRef.current;\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.findIndex(panel => panel.current.id === id);\n    const size = sizes[index];\n    const units = unitsFromParams ?? unitsFromProps;\n    if (units === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      return size / 100 * groupSizePixels;\n    } else {\n      return size;\n    }\n  }, [groupId, sizes]);\n  const getPanelStyle = useCallback((id, defaultSize) => {\n    const {\n      panels\n    } = committedValuesRef.current;\n\n    // Before mounting, Panels will not yet have registered themselves.\n    // This includes server rendering.\n    // At this point the best we can do is render everything with the same size.\n    if (panels.size === 0) {\n      {\n        if (!devWarningsRef.current.didLogDefaultSizeWarning) ;\n      }\n      return {\n        flexBasis: 0,\n        flexGrow: defaultSize != null ? defaultSize : undefined,\n        flexShrink: 1,\n        // Without this, Panel sizes may be unintentionally overridden by their content.\n        overflow: \"hidden\"\n      };\n    }\n    const flexGrow = getFlexGrow(panels, id, sizes);\n    return {\n      flexBasis: 0,\n      flexGrow,\n      flexShrink: 1,\n      // Without this, Panel sizes may be unintentionally overridden by their content.\n      overflow: \"hidden\",\n      // Disable pointer events inside of a panel during resize.\n      // This avoid edge cases like nested iframes.\n      pointerEvents: disablePointerEventsDuringResize && activeHandleId !== null ? \"none\" : undefined\n    };\n  }, [activeHandleId, disablePointerEventsDuringResize, sizes]);\n  const registerPanel = useCallback((id, panelRef) => {\n    const {\n      units\n    } = committedValuesRef.current;\n    validatePanelProps(units, panelRef);\n    setPanels(prevPanels => {\n      if (prevPanels.has(id)) {\n        return prevPanels;\n      }\n      const nextPanels = new Map(prevPanels);\n      nextPanels.set(id, panelRef);\n      return nextPanels;\n    });\n  }, []);\n  const registerResizeHandle = useCallback(handleId => {\n    const resizeHandler = event => {\n      event.preventDefault();\n      const {\n        direction,\n        panels,\n        sizes: prevSizes\n      } = committedValuesRef.current;\n      const panelsArray = panelsMapToSortedArray(panels);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n      if (idBefore == null || idAfter == null) {\n        return;\n      }\n      let movement = getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragStateRef.current);\n      if (movement === 0) {\n        return;\n      }\n      const groupElement = getPanelGroup(groupId);\n      const rect = groupElement.getBoundingClientRect();\n      const isHorizontal = direction === \"horizontal\";\n\n      // Support RTL layouts\n      if (document.dir === \"rtl\" && isHorizontal) {\n        movement = -movement;\n      }\n      const size = isHorizontal ? rect.width : rect.height;\n      const delta = movement / size * 100;\n\n      // If a validateLayout method has been provided\n      // it's important to use it before updating the mouse cursor\n      const nextSizes = adjustByDelta(event, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, initialDragStateRef.current);\n      const sizesChanged = !areEqual(prevSizes, nextSizes);\n\n      // Don't update cursor for resizes triggered by keyboard interactions.\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change–\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          if (!sizesChanged) {\n            // If the pointer has moved too far to resize the panel any further,\n            // update the cursor style for a visual clue.\n            // This mimics VS Code behavior.\n\n            if (isHorizontal) {\n              setGlobalCursorStyle(movement < 0 ? \"horizontal-min\" : \"horizontal-max\");\n            } else {\n              setGlobalCursorStyle(movement < 0 ? \"vertical-min\" : \"vertical-max\");\n            }\n          } else {\n            // Reset the cursor style to the the normal resize cursor.\n            setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n          }\n        }\n      }\n      if (sizesChanged) {\n        const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n        // It's okay to bypass in this case because we already validated above\n        setSizes(nextSizes);\n\n        // If resize change handlers have been declared, this is the time to call them.\n        // Trigger user callbacks after updating state, so that user code can override the sizes.\n        callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n      }\n      prevDeltaRef.current = delta;\n    };\n    return resizeHandler;\n  }, [groupId]);\n  const unregisterPanel = useCallback(id => {\n    setPanels(prevPanels => {\n      if (!prevPanels.has(id)) {\n        return prevPanels;\n      }\n      const nextPanels = new Map(prevPanels);\n      nextPanels.delete(id);\n      return nextPanels;\n    });\n  }, []);\n  const collapsePanel = useCallback(id => {\n    const {\n      panels,\n      sizes: prevSizes\n    } = committedValuesRef.current;\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    const {\n      collapsedSize,\n      collapsible\n    } = panel.current;\n    if (!collapsible) {\n      return;\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize === collapsedSize) {\n      // Panel is already collapsed.\n      return;\n    }\n    panelSizeBeforeCollapse.current.set(id, currentSize);\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize : collapsedSize - currentSize;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const expandPanel = useCallback(id => {\n    const {\n      panels,\n      sizes: prevSizes\n    } = committedValuesRef.current;\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    const {\n      collapsedSize,\n      minSize\n    } = panel.current;\n    const sizeBeforeCollapse = panelSizeBeforeCollapse.current.get(id) || minSize;\n    if (!sizeBeforeCollapse) {\n      return;\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize !== collapsedSize) {\n      // Panel is already expanded.\n      return;\n    }\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? collapsedSize - sizeBeforeCollapse : sizeBeforeCollapse;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const resizePanel = useCallback((id, nextSize, unitsFromParams) => {\n    const {\n      id: groupId,\n      panels,\n      sizes: prevSizes,\n      units\n    } = committedValuesRef.current;\n    if ((unitsFromParams || units) === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      nextSize = nextSize / groupSizePixels * 100;\n    }\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    let {\n      collapsedSize,\n      collapsible,\n      maxSize,\n      minSize\n    } = panel.current;\n    if (units === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      minSize = minSize / groupSizePixels * 100;\n      if (maxSize != null) {\n        maxSize = maxSize / groupSizePixels * 100;\n      }\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize === nextSize) {\n      return;\n    }\n    if (collapsible && nextSize === collapsedSize) ; else {\n      const unsafeNextSize = nextSize;\n      nextSize = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSize));\n      {\n        if (unsafeNextSize !== nextSize) {\n          console.error(`Invalid size (${unsafeNextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`);\n        }\n      }\n    }\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize - nextSize : nextSize - currentSize;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const context = useMemo(() => ({\n    activeHandleId,\n    collapsePanel,\n    direction,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging: (id, event) => {\n      setActiveHandleId(id);\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        const handleElement = getResizeHandle(id);\n        initialDragStateRef.current = {\n          dragHandleRect: handleElement.getBoundingClientRect(),\n          dragOffset: getDragOffset(event, id, direction),\n          sizes: committedValuesRef.current.sizes\n        };\n      }\n    },\n    stopDragging: () => {\n      resetGlobalCursorStyle();\n      setActiveHandleId(null);\n      initialDragStateRef.current = null;\n    },\n    units,\n    unregisterPanel\n  }), [activeHandleId, collapsePanel, direction, expandPanel, getPanelSize, getPanelStyle, groupId, registerPanel, registerResizeHandle, resizePanel, units, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    children: createElement(Type, {\n      children,\n      className: classNameFromProps,\n      \"data-panel-group\": \"\",\n      \"data-panel-group-direction\": direction,\n      \"data-panel-group-id\": groupId,\n      \"data-panel-group-units\": units,\n      style: {\n        ...style,\n        ...styleFromProps\n      }\n    }),\n    value: context\n  });\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  id: idFromProps = null,\n  onDragging,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const divElementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onDragging\n  });\n  useEffect(() => {\n    callbacksRef.current.onDragging = onDragging;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    activeHandleId,\n    direction,\n    groupId,\n    registerResizeHandle,\n    startDragging,\n    stopDragging\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const isDragging = activeHandleId === resizeHandleId;\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const stopDraggingAndBlur = useCallback(() => {\n    // Clicking on the drag handle shouldn't leave it focused;\n    // That would cause the PanelGroup to think it was still active.\n    const div = divElementRef.current;\n    div.blur();\n    stopDragging();\n    const {\n      onDragging\n    } = callbacksRef.current;\n    if (onDragging) {\n      onDragging(false);\n    }\n  }, [stopDragging]);\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandle(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandle]);\n  useEffect(() => {\n    if (disabled || resizeHandler == null || !isDragging) {\n      return;\n    }\n    const onMove = event => {\n      resizeHandler(event);\n    };\n    const onMouseLeave = event => {\n      resizeHandler(event);\n    };\n    const divElement = divElementRef.current;\n    const targetDocument = divElement.ownerDocument;\n    targetDocument.body.addEventListener(\"contextmenu\", stopDraggingAndBlur);\n    targetDocument.body.addEventListener(\"mousemove\", onMove);\n    targetDocument.body.addEventListener(\"touchmove\", onMove);\n    targetDocument.body.addEventListener(\"mouseleave\", onMouseLeave);\n    window.addEventListener(\"mouseup\", stopDraggingAndBlur);\n    window.addEventListener(\"touchend\", stopDraggingAndBlur);\n    return () => {\n      targetDocument.body.removeEventListener(\"contextmenu\", stopDraggingAndBlur);\n      targetDocument.body.removeEventListener(\"mousemove\", onMove);\n      targetDocument.body.removeEventListener(\"touchmove\", onMove);\n      targetDocument.body.removeEventListener(\"mouseleave\", onMouseLeave);\n      window.removeEventListener(\"mouseup\", stopDraggingAndBlur);\n      window.removeEventListener(\"touchend\", stopDraggingAndBlur);\n    };\n  }, [direction, disabled, isDragging, resizeHandler, stopDraggingAndBlur]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler\n  });\n  const style = {\n    cursor: getCursorStyle(direction),\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-resize-handle-active\": isDragging ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId,\n    onBlur: () => setIsFocused(false),\n    onFocus: () => setIsFocused(true),\n    onMouseDown: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    onMouseUp: stopDraggingAndBlur,\n    onTouchCancel: stopDraggingAndBlur,\n    onTouchEnd: stopDraggingAndBlur,\n    onTouchStart: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    ref: divElementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex: 0\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\nexport { Panel, PanelGroup, PanelResizeHandle, getAvailableGroupSizePixels };\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;;AAE9B;;AAEA;;AAEA,MAAM;EACJC,aAAa;EACbC,aAAa;EACbC,UAAU;EACVC,WAAW;EACXC,UAAU;EACVC,SAAS;EACTC,mBAAmB;EACnBC,eAAe;EACfC,OAAO;EACPC,MAAM;EACNC;AACF,CAAC,GAAGX,KAAK;;AAET;AACA,MAAMY,KAAK,GAAGZ,KAAK,CAAC,OAAO,CAACa,QAAQ,CAAC,CAAC,CAAC;AAEvC,MAAMC,yBAAyB,GAAGN,eAAe;AAEjD,MAAMO,YAAY,GAAG,OAAOH,KAAK,KAAK,UAAU,GAAGA,KAAK,GAAG,MAAM,IAAI;AACrE,IAAII,OAAO,GAAG,CAAC;AACf,SAASC,WAAWA,CAACC,YAAY,GAAG,IAAI,EAAE;EACxC,MAAMC,WAAW,GAAGJ,YAAY,CAAC,CAAC;EAClC,MAAMK,KAAK,GAAGV,MAAM,CAACQ,YAAY,IAAIC,WAAW,IAAI,IAAI,CAAC;EACzD,IAAIC,KAAK,CAACC,OAAO,KAAK,IAAI,EAAE;IAC1BD,KAAK,CAACC,OAAO,GAAG,EAAE,GAAGL,OAAO,EAAE;EAChC;EACA,OAAOI,KAAK,CAACC,OAAO;AACtB;AAEA,MAAMC,iBAAiB,GAAGpB,aAAa,CAAC,IAAI,CAAC;AAC7CoB,iBAAiB,CAACC,WAAW,GAAG,mBAAmB;AAEnD,SAASC,qBAAqBA,CAAC;EAC7BC,QAAQ,GAAG,IAAI;EACfC,SAAS,EAAEC,kBAAkB,GAAG,EAAE;EAClCC,aAAa,GAAG,CAAC;EACjBC,WAAW,GAAG,KAAK;EACnBC,WAAW,GAAG,IAAI;EAClBC,YAAY;EACZC,EAAE,EAAEC,WAAW,GAAG,IAAI;EACtBC,OAAO,GAAG,IAAI;EACdC,OAAO;EACPC,UAAU,GAAG,IAAI;EACjBC,QAAQ,GAAG,IAAI;EACfC,KAAK,GAAG,IAAI;EACZC,KAAK,EAAEC,cAAc,GAAG,CAAC,CAAC;EAC1BC,OAAO,EAAEC,IAAI,GAAG;AAClB,CAAC,EAAE;EACD,MAAMC,OAAO,GAAGtC,UAAU,CAACiB,iBAAiB,CAAC;EAC7C,IAAIqB,OAAO,KAAK,IAAI,EAAE;IACpB,MAAMC,KAAK,CAAE,iEAAgE,CAAC;EAChF;EACA,MAAMC,OAAO,GAAG5B,WAAW,CAACgB,WAAW,CAAC;EACxC,MAAM;IACJa,aAAa;IACbC,WAAW;IACXC,YAAY;IACZC,aAAa;IACbC,aAAa;IACbC,WAAW;IACXC,KAAK;IACLC;EACF,CAAC,GAAGV,OAAO;EACX,IAAIR,OAAO,IAAI,IAAI,EAAE;IACnB,IAAIiB,KAAK,KAAK,aAAa,EAAE;MAC3B;MACAjB,OAAO,GAAG,EAAE;IACd,CAAC,MAAM;MACL;MACAA,OAAO,GAAG,CAAC;IACb;EACF;;EAEA;EACA,MAAMmB,YAAY,GAAG5C,MAAM,CAAC;IAC1B0B,UAAU;IACVC;EACF,CAAC,CAAC;EACF/B,SAAS,CAAC,MAAM;IACdgD,YAAY,CAACjC,OAAO,CAACe,UAAU,GAAGA,UAAU;IAC5CkB,YAAY,CAACjC,OAAO,CAACgB,QAAQ,GAAGA,QAAQ;EAC1C,CAAC,CAAC;EACF,MAAME,KAAK,GAAGU,aAAa,CAACJ,OAAO,EAAEf,WAAW,CAAC;EACjD,MAAMyB,kBAAkB,GAAG7C,MAAM,CAAC;IAChC8C,IAAI,EAAEC,kBAAkB,CAAClB,KAAK;EAChC,CAAC,CAAC;EACF,MAAMmB,YAAY,GAAGhD,MAAM,CAAC;IAC1B4C,YAAY;IACZ1B,aAAa;IACbC,WAAW;IACXC,WAAW;IACXE,EAAE,EAAEa,OAAO;IACXc,kBAAkB,EAAE1B,WAAW,IAAI,IAAI;IACvCC,OAAO;IACPC,OAAO;IACPG;EACF,CAAC,CAAC;EACFxB,yBAAyB,CAAC,MAAM;IAC9ByC,kBAAkB,CAAClC,OAAO,CAACmC,IAAI,GAAGC,kBAAkB,CAAClB,KAAK,CAAC;IAC3DmB,YAAY,CAACrC,OAAO,CAACiC,YAAY,GAAGA,YAAY;IAChDI,YAAY,CAACrC,OAAO,CAACO,aAAa,GAAGA,aAAa;IAClD8B,YAAY,CAACrC,OAAO,CAACQ,WAAW,GAAGA,WAAW;IAC9C6B,YAAY,CAACrC,OAAO,CAACS,WAAW,GAAGA,WAAW;IAC9C4B,YAAY,CAACrC,OAAO,CAACW,EAAE,GAAGa,OAAO;IACjCa,YAAY,CAACrC,OAAO,CAACsC,kBAAkB,GAAG1B,WAAW,IAAI,IAAI;IAC7DyB,YAAY,CAACrC,OAAO,CAACa,OAAO,GAAGA,OAAO;IACtCwB,YAAY,CAACrC,OAAO,CAACc,OAAO,GAAGA,OAAO;IACtCuB,YAAY,CAACrC,OAAO,CAACiB,KAAK,GAAGA,KAAK;EACpC,CAAC,CAAC;EACFxB,yBAAyB,CAAC,MAAM;IAC9BoC,aAAa,CAACL,OAAO,EAAEa,YAAY,CAAC;IACpC,OAAO,MAAM;MACXL,eAAe,CAACR,OAAO,CAAC;IAC1B,CAAC;EACH,CAAC,EAAE,CAACP,KAAK,EAAEO,OAAO,EAAEK,aAAa,EAAEG,eAAe,CAAC,CAAC;EACpD9C,mBAAmB,CAACwB,YAAY,EAAE,OAAO;IACvC6B,QAAQ,EAAEA,CAAA,KAAMd,aAAa,CAACD,OAAO,CAAC;IACtCgB,MAAM,EAAEA,CAAA,KAAMd,WAAW,CAACF,OAAO,CAAC;IAClCiB,YAAYA,CAAA,EAAG;MACb,OAAOP,kBAAkB,CAAClC,OAAO,CAACmC,IAAI,KAAK,CAAC;IAC9C,CAAC;IACDO,KAAKA,CAAA,EAAG;MACN,OAAOlB,OAAO;IAChB,CAAC;IACDmB,OAAOA,CAACZ,KAAK,EAAE;MACb,OAAOJ,YAAY,CAACH,OAAO,EAAEO,KAAK,CAAC;IACrC,CAAC;IACDa,MAAM,EAAEA,CAACC,UAAU,EAAEd,KAAK,KAAKD,WAAW,CAACN,OAAO,EAAEqB,UAAU,EAAEd,KAAK;EACvE,CAAC,CAAC,EAAE,CAACN,aAAa,EAAEC,WAAW,EAAEC,YAAY,EAAEH,OAAO,EAAEM,WAAW,CAAC,CAAC;EACrE,OAAOlD,aAAa,CAACyC,IAAI,EAAE;IACzBjB,QAAQ;IACRC,SAAS,EAAEC,kBAAkB;IAC7B,YAAY,EAAE,EAAE;IAChB,wBAAwB,EAAEE,WAAW,IAAIsC,SAAS;IAClD,eAAe,EAAEtB,OAAO;IACxB,iBAAiB,EAAEuB,UAAU,CAAC,EAAE,GAAG7B,KAAK,CAAC8B,QAAQ,CAAC,CAACC,OAAO,CAAC,CAAC,CAAC;IAC7DtC,EAAE,EAAG,iBAAgBa,OAAQ,EAAC;IAC9BN,KAAK,EAAE;MACL,GAAGA,KAAK;MACR,GAAGC;IACL;EACF,CAAC,CAAC;AACJ;AACA,MAAM+B,KAAK,GAAGpE,UAAU,CAAC,CAACqE,KAAK,EAAEC,GAAG,KAAKxE,aAAa,CAACuB,qBAAqB,EAAE;EAC5E,GAAGgD,KAAK;EACRzC,YAAY,EAAE0C;AAChB,CAAC,CAAC,CAAC;AACHjD,qBAAqB,CAACD,WAAW,GAAG,OAAO;AAC3CgD,KAAK,CAAChD,WAAW,GAAG,mBAAmB;;AAEvC;AACA,SAASkC,kBAAkBA,CAAClB,KAAK,EAAE;EACjC,MAAM;IACJ8B;EACF,CAAC,GAAG9B,KAAK;EACT,IAAI,OAAO8B,QAAQ,KAAK,QAAQ,EAAE;IAChC,OAAOD,UAAU,CAACC,QAAQ,CAAC;EAC7B,CAAC,MAAM;IACL,OAAOA,QAAQ;EACjB;AACF;AAEA,MAAMK,SAAS,GAAG,EAAE;AAEpB,SAASC,aAAaA,CAACC,KAAK,EAAEC,eAAe,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,WAAW,EAAEC,SAAS,EAAEC,uBAAuB,EAAEC,gBAAgB,EAAE;EACnI,MAAM;IACJnD,EAAE,EAAEoD,OAAO;IACXC,MAAM;IACNjC;EACF,CAAC,GAAGyB,eAAe;EACnB,MAAMS,eAAe,GAAGlC,KAAK,KAAK,QAAQ,GAAGmC,2BAA2B,CAACH,OAAO,CAAC,GAAGI,GAAG;EACvF,MAAM;IACJC,KAAK,EAAEC;EACT,CAAC,GAAGP,gBAAgB,IAAI,CAAC,CAAC;;EAE1B;EACA;EACA,MAAMQ,SAAS,GAAGD,YAAY,IAAIT,SAAS;EAC3C,MAAMW,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;EAClD,MAAMS,SAAS,GAAGH,SAAS,CAACI,MAAM,CAAC,CAAC;EACpC,IAAIC,YAAY,GAAG,CAAC;;EAEpB;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;IACE,MAAMC,OAAO,GAAGjB,WAAW,GAAG,CAAC,GAAGD,OAAO,GAAGD,QAAQ;IACpD,MAAMoB,KAAK,GAAGN,WAAW,CAACO,SAAS,CAACC,KAAK,IAAIA,KAAK,CAAC/E,OAAO,CAACW,EAAE,KAAKiE,OAAO,CAAC;IAC1E,MAAMG,KAAK,GAAGR,WAAW,CAACM,KAAK,CAAC;IAChC,MAAMG,QAAQ,GAAGV,SAAS,CAACO,KAAK,CAAC;IACjC,MAAMI,QAAQ,GAAGC,eAAe,CAACnD,KAAK,EAAEkC,eAAe,EAAEc,KAAK,EAAEC,QAAQ,EAAEA,QAAQ,GAAGG,IAAI,CAACC,GAAG,CAACzB,WAAW,CAAC,EAAEJ,KAAK,CAAC;IAClH,IAAIyB,QAAQ,KAAKC,QAAQ,EAAE;MACzB;MACA,OAAOX,SAAS;IAClB,CAAC,MAAM;MACL,IAAIW,QAAQ,KAAK,CAAC,IAAID,QAAQ,GAAG,CAAC,EAAE;QAClCnB,uBAAuB,CAACwB,GAAG,CAACT,OAAO,EAAEI,QAAQ,CAAC;MAChD;MACArB,WAAW,GAAGA,WAAW,GAAG,CAAC,GAAGqB,QAAQ,GAAGC,QAAQ,GAAGA,QAAQ,GAAGD,QAAQ;IAC3E;EACF;EACA,IAAIJ,OAAO,GAAGjB,WAAW,GAAG,CAAC,GAAGF,QAAQ,GAAGC,OAAO;EAClD,IAAImB,KAAK,GAAGN,WAAW,CAACO,SAAS,CAACC,KAAK,IAAIA,KAAK,CAAC/E,OAAO,CAACW,EAAE,KAAKiE,OAAO,CAAC;EACxE,OAAO,IAAI,EAAE;IACX,MAAMG,KAAK,GAAGR,WAAW,CAACM,KAAK,CAAC;IAChC,MAAMG,QAAQ,GAAGV,SAAS,CAACO,KAAK,CAAC;IACjC,MAAMS,cAAc,GAAGH,IAAI,CAACC,GAAG,CAACzB,WAAW,CAAC,GAAGwB,IAAI,CAACC,GAAG,CAACT,YAAY,CAAC;IACrE,MAAMM,QAAQ,GAAGC,eAAe,CAACnD,KAAK,EAAEkC,eAAe,EAAEc,KAAK,EAAEC,QAAQ,EAAEA,QAAQ,GAAGM,cAAc,EAAE/B,KAAK,CAAC;IAC3G,IAAIyB,QAAQ,KAAKC,QAAQ,EAAE;MACzB,IAAIA,QAAQ,KAAK,CAAC,IAAID,QAAQ,GAAG,CAAC,EAAE;QAClCnB,uBAAuB,CAACwB,GAAG,CAACN,KAAK,CAAC/E,OAAO,CAACW,EAAE,EAAEqE,QAAQ,CAAC;MACzD;MACAL,YAAY,IAAIK,QAAQ,GAAGC,QAAQ;MACnCR,SAAS,CAACI,KAAK,CAAC,GAAGI,QAAQ;MAC3B,IAAIN,YAAY,CAACY,WAAW,CAAClC,SAAS,CAAC,CAACmC,aAAa,CAACL,IAAI,CAACC,GAAG,CAACzB,WAAW,CAAC,CAAC4B,WAAW,CAAClC,SAAS,CAAC,EAAEP,SAAS,EAAE;QAC7G2C,OAAO,EAAE;MACX,CAAC,CAAC,IAAI,CAAC,EAAE;QACP;MACF;IACF;IACA,IAAI9B,WAAW,GAAG,CAAC,EAAE;MACnB,IAAI,EAAEkB,KAAK,GAAG,CAAC,EAAE;QACf;MACF;IACF,CAAC,MAAM;MACL,IAAI,EAAEA,KAAK,IAAIN,WAAW,CAACmB,MAAM,EAAE;QACjC;MACF;IACF;EACF;;EAEA;EACA;EACA,IAAIf,YAAY,KAAK,CAAC,EAAE;IACtB,OAAOL,SAAS;EAClB;;EAEA;EACAM,OAAO,GAAGjB,WAAW,GAAG,CAAC,GAAGD,OAAO,GAAGD,QAAQ;EAC9CoB,KAAK,GAAGN,WAAW,CAACO,SAAS,CAACC,KAAK,IAAIA,KAAK,CAAC/E,OAAO,CAACW,EAAE,KAAKiE,OAAO,CAAC;EACpEH,SAAS,CAACI,KAAK,CAAC,GAAGP,SAAS,CAACO,KAAK,CAAC,GAAGF,YAAY;EAClD,OAAOF,SAAS;AAClB;AACA,SAASkB,kBAAkBA,CAACpB,WAAW,EAAEH,KAAK,EAAEwB,4BAA4B,EAAE;EAC5ExB,KAAK,CAACyB,OAAO,CAAC,CAAC1D,IAAI,EAAE0C,KAAK,KAAK;IAC7B,MAAMiB,QAAQ,GAAGvB,WAAW,CAACM,KAAK,CAAC;IACnC,IAAI,CAACiB,QAAQ,EAAE;MACb;MACA;MACA;IACF;IACA,MAAM;MACJ7D,YAAY;MACZ1B,aAAa;MACbC,WAAW;MACXG;IACF,CAAC,GAAGmF,QAAQ,CAAC9F,OAAO;IACpB,MAAM+F,gBAAgB,GAAGH,4BAA4B,CAACjF,EAAE,CAAC;IACzD,IAAIoF,gBAAgB,KAAK5D,IAAI,EAAE;MAC7ByD,4BAA4B,CAACjF,EAAE,CAAC,GAAGwB,IAAI;MACvC,MAAM;QACJpB,UAAU;QACVC;MACF,CAAC,GAAGiB,YAAY,CAACjC,OAAO;MACxB,IAAIgB,QAAQ,EAAE;QACZA,QAAQ,CAACmB,IAAI,EAAE4D,gBAAgB,CAAC;MAClC;MACA,IAAIvF,WAAW,IAAIO,UAAU,EAAE;QAC7B,IAAI,CAACgF,gBAAgB,IAAI,IAAI,IAAIA,gBAAgB,KAAKxF,aAAa,KAAK4B,IAAI,KAAK5B,aAAa,EAAE;UAC9FQ,UAAU,CAAC,KAAK,CAAC;QACnB,CAAC,MAAM,IAAIgF,gBAAgB,KAAKxF,aAAa,IAAI4B,IAAI,KAAK5B,aAAa,EAAE;UACvEQ,UAAU,CAAC,IAAI,CAAC;QAClB;MACF;IACF;EACF,CAAC,CAAC;AACJ;AACA,SAASiF,sBAAsBA,CAAC;EAC9BjC,OAAO;EACPC,MAAM;EACNjC;AACF,CAAC,EAAE;EACD,MAAMkC,eAAe,GAAGlC,KAAK,KAAK,QAAQ,GAAGmC,2BAA2B,CAACH,OAAO,CAAC,GAAGI,GAAG;EACvF,MAAMI,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;EAClD,MAAMI,KAAK,GAAG6B,KAAK,CAAC1B,WAAW,CAACmB,MAAM,CAAC;EACvC,IAAIQ,kBAAkB,GAAG,CAAC;EAC1B,IAAIC,aAAa,GAAG,GAAG;;EAEvB;EACA;EACA,KAAK,IAAItB,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGN,WAAW,CAACmB,MAAM,EAAEb,KAAK,EAAE,EAAE;IACvD,MAAME,KAAK,GAAGR,WAAW,CAACM,KAAK,CAAC;IAChC,MAAM;MACJpE;IACF,CAAC,GAAGsE,KAAK,CAAC/E,OAAO;IACjB,IAAIS,WAAW,IAAI,IAAI,EAAE;MACvByF,kBAAkB,EAAE;MACpB9B,KAAK,CAACS,KAAK,CAAC,GAAG9C,KAAK,KAAK,QAAQ,GAAGtB,WAAW,GAAGwD,eAAe,GAAG,GAAG,GAAGxD,WAAW;MACrF0F,aAAa,IAAI/B,KAAK,CAACS,KAAK,CAAC;IAC/B;EACF;;EAEA;EACA;EACA,KAAK,IAAIA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGN,WAAW,CAACmB,MAAM,EAAEb,KAAK,EAAE,EAAE;IACvD,MAAME,KAAK,GAAGR,WAAW,CAACM,KAAK,CAAC;IAChC,IAAI;MACFpE,WAAW;MACXE,EAAE;MACFE,OAAO;MACPC;IACF,CAAC,GAAGiE,KAAK,CAAC/E,OAAO;IACjB,IAAIS,WAAW,IAAI,IAAI,EAAE;MACvB;IACF;IACA,IAAIsB,KAAK,KAAK,QAAQ,EAAE;MACtBjB,OAAO,GAAGA,OAAO,GAAGmD,eAAe,GAAG,GAAG;MACzC,IAAIpD,OAAO,IAAI,IAAI,EAAE;QACnBA,OAAO,GAAGA,OAAO,GAAGoD,eAAe,GAAG,GAAG;MAC3C;IACF;IACA,MAAMmC,eAAe,GAAG7B,WAAW,CAACmB,MAAM,GAAGQ,kBAAkB;IAC/D,MAAM/D,IAAI,GAAGgD,IAAI,CAACkB,GAAG,CAACxF,OAAO,IAAI,IAAI,GAAGA,OAAO,GAAG,GAAG,EAAEsE,IAAI,CAACmB,GAAG,CAACxF,OAAO,EAAEqF,aAAa,GAAGC,eAAe,CAAC,CAAC;IAC1GhC,KAAK,CAACS,KAAK,CAAC,GAAG1C,IAAI;IACnB+D,kBAAkB,EAAE;IACpBC,aAAa,IAAIhE,IAAI;EACvB;;EAEA;EACA;EACA,IAAIgE,aAAa,KAAK,CAAC,EAAE;IACvB,KAAK,IAAItB,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGN,WAAW,CAACmB,MAAM,EAAEb,KAAK,EAAE,EAAE;MACvD,MAAME,KAAK,GAAGR,WAAW,CAACM,KAAK,CAAC;MAChC,IAAI;QACFhE,OAAO;QACPC;MACF,CAAC,GAAGiE,KAAK,CAAC/E,OAAO;MACjB,IAAI+B,KAAK,KAAK,QAAQ,EAAE;QACtBjB,OAAO,GAAGA,OAAO,GAAGmD,eAAe,GAAG,GAAG;QACzC,IAAIpD,OAAO,IAAI,IAAI,EAAE;UACnBA,OAAO,GAAGA,OAAO,GAAGoD,eAAe,GAAG,GAAG;QAC3C;MACF;MACA,MAAM9B,IAAI,GAAGgD,IAAI,CAACkB,GAAG,CAACxF,OAAO,IAAI,IAAI,GAAGA,OAAO,GAAG,GAAG,EAAEsE,IAAI,CAACmB,GAAG,CAACxF,OAAO,EAAEsD,KAAK,CAACS,KAAK,CAAC,GAAGsB,aAAa,CAAC,CAAC;MACvG,IAAIhE,IAAI,KAAKiC,KAAK,CAACS,KAAK,CAAC,EAAE;QACzBsB,aAAa,IAAIhE,IAAI,GAAGiC,KAAK,CAACS,KAAK,CAAC;QACpCT,KAAK,CAACS,KAAK,CAAC,GAAG1C,IAAI;;QAEnB;QACA,IAAIgD,IAAI,CAACC,GAAG,CAACe,aAAa,CAAC,CAAClD,OAAO,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;UAClD;QACF;MACF;IACF;EACF;;EAEA;EACA,IAAIkC,IAAI,CAACC,GAAG,CAACe,aAAa,CAAC,CAAClD,OAAO,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;IAClD;MACEsD,OAAO,CAACC,KAAK,CAAE,oFAAmF,CAAC,GAAG,GAAGL,aAAa,EAAElD,OAAO,CAAC,CAAC,CAAE,mEAAkE,CAAC;IACxM;EACF;EACA,OAAOmB,KAAK;AACd;AACA,SAASqC,oBAAoBA,CAAC9F,EAAE,EAAE4D,WAAW,EAAE;EAC7C,IAAIA,WAAW,CAACmB,MAAM,GAAG,CAAC,EAAE;IAC1B,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC;EACrB;EACA,MAAMb,KAAK,GAAGN,WAAW,CAACO,SAAS,CAACC,KAAK,IAAIA,KAAK,CAAC/E,OAAO,CAACW,EAAE,KAAKA,EAAE,CAAC;EACrE,IAAIkE,KAAK,GAAG,CAAC,EAAE;IACb,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC;EACrB;EACA,MAAM6B,WAAW,GAAG7B,KAAK,KAAKN,WAAW,CAACmB,MAAM,GAAG,CAAC;EACpD,MAAMjC,QAAQ,GAAGiD,WAAW,GAAGnC,WAAW,CAACM,KAAK,GAAG,CAAC,CAAC,CAAC7E,OAAO,CAACW,EAAE,GAAGA,EAAE;EACrE,MAAM+C,OAAO,GAAGgD,WAAW,GAAG/F,EAAE,GAAG4D,WAAW,CAACM,KAAK,GAAG,CAAC,CAAC,CAAC7E,OAAO,CAACW,EAAE;EACpE,OAAO,CAAC8C,QAAQ,EAAEC,OAAO,CAAC;AAC5B;AACA,SAASQ,2BAA2BA,CAACH,OAAO,EAAE;EAC5C,MAAM4C,iBAAiB,GAAGC,aAAa,CAAC7C,OAAO,CAAC;EAChD,IAAI4C,iBAAiB,IAAI,IAAI,EAAE;IAC7B,OAAOxC,GAAG;EACZ;EACA,MAAM0C,SAAS,GAAGF,iBAAiB,CAACG,YAAY,CAAC,4BAA4B,CAAC;EAC9E,MAAMC,aAAa,GAAGC,wBAAwB,CAACjD,OAAO,CAAC;EACvD,IAAI8C,SAAS,KAAK,YAAY,EAAE;IAC9B,OAAOF,iBAAiB,CAACM,WAAW,GAAGF,aAAa,CAACG,MAAM,CAAC,CAACC,WAAW,EAAEC,MAAM,KAAK;MACnF,OAAOD,WAAW,GAAGC,MAAM,CAACH,WAAW;IACzC,CAAC,EAAE,CAAC,CAAC;EACP,CAAC,MAAM;IACL,OAAON,iBAAiB,CAACU,YAAY,GAAGN,aAAa,CAACG,MAAM,CAAC,CAACC,WAAW,EAAEC,MAAM,KAAK;MACpF,OAAOD,WAAW,GAAGC,MAAM,CAACC,YAAY;IAC1C,CAAC,EAAE,CAAC,CAAC;EACP;AACF;;AAEA;AACA;AACA,SAASC,WAAWA,CAACtD,MAAM,EAAErD,EAAE,EAAEyD,KAAK,EAAE;EACtC,IAAIJ,MAAM,CAAC7B,IAAI,KAAK,CAAC,EAAE;IACrB,OAAO,KAAK;EACd;EACA,MAAMoC,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;EAClD,MAAMa,KAAK,GAAGN,WAAW,CAACO,SAAS,CAACC,KAAK,IAAIA,KAAK,CAAC/E,OAAO,CAACW,EAAE,KAAKA,EAAE,CAAC;EACrE,MAAMwB,IAAI,GAAGiC,KAAK,CAACS,KAAK,CAAC;EACzB,IAAI1C,IAAI,IAAI,IAAI,EAAE;IAChB,OAAO,GAAG;EACZ;EACA,OAAOA,IAAI,CAACoD,WAAW,CAAClC,SAAS,CAAC;AACpC;AACA,SAASkE,QAAQA,CAAC5G,EAAE,EAAE;EACpB,MAAM6G,OAAO,GAAGC,QAAQ,CAACC,aAAa,CAAE,mBAAkB/G,EAAG,IAAG,CAAC;EACjE,IAAI6G,OAAO,EAAE;IACX,OAAOA,OAAO;EAChB;EACA,OAAO,IAAI;AACb;AACA,SAASZ,aAAaA,CAACjG,EAAE,EAAE;EACzB,MAAM6G,OAAO,GAAGC,QAAQ,CAACC,aAAa,CAAE,yBAAwB/G,EAAG,IAAG,CAAC;EACvE,IAAI6G,OAAO,EAAE;IACX,OAAOA,OAAO;EAChB;EACA,OAAO,IAAI;AACb;AACA,SAASG,eAAeA,CAAChH,EAAE,EAAE;EAC3B,MAAM6G,OAAO,GAAGC,QAAQ,CAACC,aAAa,CAAE,iCAAgC/G,EAAG,IAAG,CAAC;EAC/E,IAAI6G,OAAO,EAAE;IACX,OAAOA,OAAO;EAChB;EACA,OAAO,IAAI;AACb;AACA,SAASI,oBAAoBA,CAACjH,EAAE,EAAE;EAChC,MAAMkH,OAAO,GAAGC,gBAAgB,CAAC,CAAC;EAClC,MAAMjD,KAAK,GAAGgD,OAAO,CAAC/C,SAAS,CAACsC,MAAM,IAAIA,MAAM,CAACN,YAAY,CAAC,6BAA6B,CAAC,KAAKnG,EAAE,CAAC;EACpG,OAAOkE,KAAK,IAAI,IAAI;AACtB;AACA,SAASiD,gBAAgBA,CAAA,EAAG;EAC1B,OAAO7B,KAAK,CAAC8B,IAAI,CAACN,QAAQ,CAACO,gBAAgB,CAAE,+BAA8B,CAAC,CAAC;AAC/E;AACA,SAAShB,wBAAwBA,CAACjD,OAAO,EAAE;EACzC,OAAOkC,KAAK,CAAC8B,IAAI,CAACN,QAAQ,CAACO,gBAAgB,CAAE,sDAAqDjE,OAAQ,IAAG,CAAC,CAAC;AACjH;AACA,SAASkE,uBAAuBA,CAAClE,OAAO,EAAEmE,QAAQ,EAAE3D,WAAW,EAAE;EAC/D,MAAM6C,MAAM,GAAGO,eAAe,CAACO,QAAQ,CAAC;EACxC,MAAML,OAAO,GAAGb,wBAAwB,CAACjD,OAAO,CAAC;EACjD,MAAMc,KAAK,GAAGuC,MAAM,GAAGS,OAAO,CAACM,OAAO,CAACf,MAAM,CAAC,GAAG,CAAC,CAAC;EACnD,MAAM3D,QAAQ,GAAGc,WAAW,CAACM,KAAK,CAAC,EAAE7E,OAAO,EAAEW,EAAE,IAAI,IAAI;EACxD,MAAM+C,OAAO,GAAGa,WAAW,CAACM,KAAK,GAAG,CAAC,CAAC,EAAE7E,OAAO,EAAEW,EAAE,IAAI,IAAI;EAC3D,OAAO,CAAC8C,QAAQ,EAAEC,OAAO,CAAC;AAC5B;AACA,SAASc,sBAAsBA,CAACR,MAAM,EAAE;EACtC,OAAOiC,KAAK,CAAC8B,IAAI,CAAC/D,MAAM,CAACoE,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAACC,MAAM,EAAEC,MAAM,KAAK;IAC1D,MAAMC,MAAM,GAAGF,MAAM,CAACtI,OAAO,CAACiB,KAAK;IACnC,MAAMwH,MAAM,GAAGF,MAAM,CAACvI,OAAO,CAACiB,KAAK;IACnC,IAAIuH,MAAM,IAAI,IAAI,IAAIC,MAAM,IAAI,IAAI,EAAE;MACpC,OAAO,CAAC;IACV,CAAC,MAAM,IAAID,MAAM,IAAI,IAAI,EAAE;MACzB,OAAO,CAAC,CAAC;IACX,CAAC,MAAM,IAAIC,MAAM,IAAI,IAAI,EAAE;MACzB,OAAO,CAAC;IACV,CAAC,MAAM;MACL,OAAOD,MAAM,GAAGC,MAAM;IACxB;EACF,CAAC,CAAC;AACJ;AACA,SAASvD,eAAeA,CAACnD,KAAK,EAAEkC,eAAe,EAAEc,KAAK,EAAE2D,QAAQ,EAAEzD,QAAQ,EAAE1B,KAAK,GAAG,IAAI,EAAE;EACxF,IAAI;IACFhD,aAAa;IACbC,WAAW;IACXK,OAAO;IACPC;EACF,CAAC,GAAGiE,KAAK,CAAC/E,OAAO;EACjB,IAAI+B,KAAK,KAAK,QAAQ,EAAE;IACtBxB,aAAa,GAAGA,aAAa,GAAG0D,eAAe,GAAG,GAAG;IACrD,IAAIpD,OAAO,IAAI,IAAI,EAAE;MACnBA,OAAO,GAAGA,OAAO,GAAGoD,eAAe,GAAG,GAAG;IAC3C;IACAnD,OAAO,GAAGA,OAAO,GAAGmD,eAAe,GAAG,GAAG;EAC3C;EACA,IAAIzD,WAAW,EAAE;IACf,IAAIkI,QAAQ,GAAGnI,aAAa,EAAE;MAC5B;MACA,IAAI0E,QAAQ,IAAInE,OAAO,GAAG,CAAC,GAAGP,aAAa,EAAE;QAC3C,OAAOA,aAAa;MACtB;IACF,CAAC,MAAM;MACL,MAAMoI,eAAe,GAAGpF,KAAK,EAAEqF,IAAI,EAAEC,UAAU,CAAC,KAAK,CAAC;MACtD,IAAI,CAACF,eAAe,EAAE;QACpB;QACA;QACA;QACA,IAAI1D,QAAQ,GAAGnE,OAAO,EAAE;UACtB,OAAOP,aAAa;QACtB;MACF;IACF;EACF;EACA,OAAO4E,IAAI,CAACkB,GAAG,CAACxF,OAAO,IAAI,IAAI,GAAGA,OAAO,GAAG,GAAG,EAAEsE,IAAI,CAACmB,GAAG,CAACxF,OAAO,EAAEmE,QAAQ,CAAC,CAAC;AAC/E;AACA,SAAS6D,kBAAkBA,CAAC/G,KAAK,EAAEgH,SAAS,EAAE;EAC5C,MAAM;IACJvI,WAAW;IACXC,WAAW;IACXI,OAAO;IACPC;EACF,CAAC,GAAGiI,SAAS,CAAC/I,OAAO;;EAErB;EACA,IAAIc,OAAO,GAAG,CAAC,IAAIiB,KAAK,KAAK,aAAa,IAAIjB,OAAO,GAAG,GAAG,EAAE;IAC3D;MACEyF,OAAO,CAACC,KAAK,CAAE,mCAAkC1F,OAAQ,EAAC,CAAC;IAC7D;IACAiI,SAAS,CAAC/I,OAAO,CAACc,OAAO,GAAG,CAAC;EAC/B;EACA,IAAID,OAAO,IAAI,IAAI,EAAE;IACnB,IAAIA,OAAO,GAAG,CAAC,IAAIkB,KAAK,KAAK,aAAa,IAAIlB,OAAO,GAAG,GAAG,EAAE;MAC3D;QACE0F,OAAO,CAACC,KAAK,CAAE,mCAAkC3F,OAAQ,EAAC,CAAC;MAC7D;MACAkI,SAAS,CAAC/I,OAAO,CAACa,OAAO,GAAG,IAAI;IAClC;EACF;EACA,IAAIJ,WAAW,KAAK,IAAI,EAAE;IACxB,IAAIA,WAAW,GAAG,CAAC,IAAIsB,KAAK,KAAK,aAAa,IAAItB,WAAW,GAAG,GAAG,EAAE;MACnE;QACE8F,OAAO,CAACC,KAAK,CAAE,uCAAsC/F,WAAY,EAAC,CAAC;MACrE;MACAsI,SAAS,CAAC/I,OAAO,CAACS,WAAW,GAAG,IAAI;IACtC,CAAC,MAAM,IAAIA,WAAW,GAAGK,OAAO,IAAI,CAACN,WAAW,EAAE;MAChD;QACE+F,OAAO,CAACC,KAAK,CAAE,kBAAiB1F,OAAQ,yCAAwCL,WAAY,GAAE,CAAC;MACjG;MACAsI,SAAS,CAAC/I,OAAO,CAACS,WAAW,GAAGK,OAAO;IACzC,CAAC,MAAM,IAAID,OAAO,IAAI,IAAI,IAAIJ,WAAW,GAAGI,OAAO,EAAE;MACnD;QACE0F,OAAO,CAACC,KAAK,CAAE,kBAAiB3F,OAAQ,sCAAqCJ,WAAY,GAAE,CAAC;MAC9F;MACAsI,SAAS,CAAC/I,OAAO,CAACS,WAAW,GAAGI,OAAO;IACzC;EACF;AACF;AACA,SAASmI,wBAAwBA,CAAC;EAChCjF,OAAO;EACPC,MAAM;EACNS,SAAS;EACTb,SAAS;EACT7B;AACF,CAAC,EAAE;EACD;EACA0C,SAAS,GAAG,CAAC,GAAGA,SAAS,CAAC;EAC1B,MAAMF,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;EAClD,MAAMC,eAAe,GAAGlC,KAAK,KAAK,QAAQ,GAAGmC,2BAA2B,CAACH,OAAO,CAAC,GAAGI,GAAG;EACvF,IAAIgC,aAAa,GAAG,CAAC;;EAErB;EACA,KAAK,IAAItB,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGN,WAAW,CAACmB,MAAM,EAAEb,KAAK,EAAE,EAAE;IACvD,MAAME,KAAK,GAAGR,WAAW,CAACM,KAAK,CAAC;IAChC,MAAM6D,QAAQ,GAAG9E,SAAS,CAACiB,KAAK,CAAC;IACjC,MAAMI,QAAQ,GAAGR,SAAS,CAACI,KAAK,CAAC;IACjC,MAAMoE,YAAY,GAAG/D,eAAe,CAACnD,KAAK,EAAEkC,eAAe,EAAEc,KAAK,EAAE2D,QAAQ,EAAEzD,QAAQ,CAAC;IACvF,IAAIA,QAAQ,IAAIgE,YAAY,EAAE;MAC5B9C,aAAa,IAAIlB,QAAQ,GAAGgE,YAAY;MACxCxE,SAAS,CAACI,KAAK,CAAC,GAAGoE,YAAY;MAC/B;QACE1C,OAAO,CAACC,KAAK,CAAE,iBAAgBvB,QAAS,0BAAyBF,KAAK,CAAC/E,OAAO,CAACW,EAAG,8CAA6C,CAAC;MAClI;IACF;EACF;;EAEA;EACA;EACA,IAAIwF,aAAa,CAAClD,OAAO,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;IACxC,KAAK,IAAI4B,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGN,WAAW,CAACmB,MAAM,EAAEb,KAAK,EAAE,EAAE;MACvD,MAAME,KAAK,GAAGR,WAAW,CAACM,KAAK,CAAC;MAChC,IAAI;QACFhE,OAAO;QACPC;MACF,CAAC,GAAGiE,KAAK,CAAC/E,OAAO;MACjB,IAAI+B,KAAK,KAAK,QAAQ,EAAE;QACtBjB,OAAO,GAAGA,OAAO,GAAGmD,eAAe,GAAG,GAAG;QACzC,IAAIpD,OAAO,IAAI,IAAI,EAAE;UACnBA,OAAO,GAAGA,OAAO,GAAGoD,eAAe,GAAG,GAAG;QAC3C;MACF;MACA,MAAM9B,IAAI,GAAGgD,IAAI,CAACkB,GAAG,CAACxF,OAAO,IAAI,IAAI,GAAGA,OAAO,GAAG,GAAG,EAAEsE,IAAI,CAACmB,GAAG,CAACxF,OAAO,EAAE2D,SAAS,CAACI,KAAK,CAAC,GAAGsB,aAAa,CAAC,CAAC;MAC3G,IAAIhE,IAAI,KAAKsC,SAAS,CAACI,KAAK,CAAC,EAAE;QAC7BsB,aAAa,IAAIhE,IAAI,GAAGsC,SAAS,CAACI,KAAK,CAAC;QACxCJ,SAAS,CAACI,KAAK,CAAC,GAAG1C,IAAI;;QAEvB;QACA,IAAIgD,IAAI,CAACC,GAAG,CAACe,aAAa,CAAC,CAAClD,OAAO,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;UAClD;QACF;MACF;IACF;EACF;;EAEA;EACA,IAAIkD,aAAa,CAAClD,OAAO,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;IACxC;MACEsD,OAAO,CAACC,KAAK,CAAE,qFAAoF,GAAG,GAAGL,aAAc,GAAE,CAAC;IAC5H;EACF;EACA,OAAO1B,SAAS;AAClB;AAEA,SAASyE,MAAMA,CAACC,iBAAiB,EAAEC,OAAO,GAAG,mBAAmB,EAAE;EAChE,IAAI,CAACD,iBAAiB,EAAE;IACtB5C,OAAO,CAACC,KAAK,CAAC4C,OAAO,CAAC;IACtB,MAAM7H,KAAK,CAAC6H,OAAO,CAAC;EACtB;AACF;;AAEA;;AAEA,SAASC,mCAAmCA,CAAC;EAC3CnH,kBAAkB;EAClB6B,OAAO;EACPC,MAAM;EACNsF,QAAQ;EACRlF,KAAK;EACLP;AACF,CAAC,EAAE;EACD5E,SAAS,CAAC,MAAM;IACd,MAAM;MACJ4H,SAAS;MACT7C;IACF,CAAC,GAAG9B,kBAAkB,CAAClC,OAAO;IAC9B,MAAMuJ,YAAY,GAAG3C,aAAa,CAAC7C,OAAO,CAAC;IAC3CmF,MAAM,CAACK,YAAY,IAAI,IAAI,EAAG,0BAAyBxF,OAAQ,GAAE,CAAC;IAClE,MAAM;MACJyF,MAAM;MACNC;IACF,CAAC,GAAGF,YAAY,CAACG,qBAAqB,CAAC,CAAC;IACxC,MAAM7B,OAAO,GAAGb,wBAAwB,CAACjD,OAAO,CAAC;IACjD,MAAM4F,gBAAgB,GAAG9B,OAAO,CAAC+B,GAAG,CAACxC,MAAM,IAAI;MAC7C,MAAMc,QAAQ,GAAGd,MAAM,CAACN,YAAY,CAAC,6BAA6B,CAAC;MACnE,MAAMvC,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;MAClD,MAAM,CAACP,QAAQ,EAAEC,OAAO,CAAC,GAAGuE,uBAAuB,CAAClE,OAAO,EAAEmE,QAAQ,EAAE3D,WAAW,CAAC;MACnF,IAAId,QAAQ,IAAI,IAAI,IAAIC,OAAO,IAAI,IAAI,EAAE;QACvC,OAAO,MAAM,CAAC,CAAC;MACjB;MACA,IAAImG,cAAc,GAAG,CAAC;MACtB,IAAIC,cAAc,GAAG,GAAG;MACxB,IAAIC,YAAY,GAAG,CAAC;MACpB,IAAIC,YAAY,GAAG,CAAC;;MAEpB;MACAzF,WAAW,CAACsB,OAAO,CAACkD,SAAS,IAAI;QAC/B,MAAM;UACJpI,EAAE;UACFE,OAAO;UACPC;QACF,CAAC,GAAGiI,SAAS,CAAC/I,OAAO;QACrB,IAAIW,EAAE,KAAK8C,QAAQ,EAAE;UACnBoG,cAAc,GAAG/I,OAAO;UACxBgJ,cAAc,GAAGjJ,OAAO,IAAI,IAAI,GAAGA,OAAO,GAAG,GAAG;QAClD,CAAC,MAAM;UACLkJ,YAAY,IAAIjJ,OAAO;UACvBkJ,YAAY,IAAInJ,OAAO,IAAI,IAAI,GAAGA,OAAO,GAAG,GAAG;QACjD;MACF,CAAC,CAAC;MACF,MAAMoJ,YAAY,GAAG9E,IAAI,CAACkB,GAAG,CAACyD,cAAc,EAAE,GAAG,GAAGC,YAAY,CAAC;MACjE,MAAMG,YAAY,GAAG/E,IAAI,CAACmB,GAAG,CAACuD,cAAc,EAAE,CAACtF,WAAW,CAACmB,MAAM,GAAG,CAAC,IAAI,GAAG,GAAGsE,YAAY,CAAC;MAC5F,MAAMhH,QAAQ,GAAGsE,WAAW,CAACtD,MAAM,EAAEP,QAAQ,EAAEW,KAAK,CAAC;MACrDgD,MAAM,CAAC+C,YAAY,CAAC,eAAe,EAAE,EAAE,GAAGhF,IAAI,CAACiF,KAAK,CAACH,YAAY,CAAC,CAAC;MACnE7C,MAAM,CAAC+C,YAAY,CAAC,eAAe,EAAE,EAAE,GAAGhF,IAAI,CAACiF,KAAK,CAACF,YAAY,CAAC,CAAC;MACnE9C,MAAM,CAAC+C,YAAY,CAAC,eAAe,EAAE,EAAE,GAAGhF,IAAI,CAACiF,KAAK,CAACC,QAAQ,CAACrH,QAAQ,CAAC,CAAC,CAAC;MACzE,MAAMsH,SAAS,GAAG/G,KAAK,IAAI;QACzB,IAAIA,KAAK,CAACgH,gBAAgB,EAAE;UAC1B;QACF;QACA,QAAQhH,KAAK,CAACiH,GAAG;UACf,KAAK,OAAO;YACV;cACEjH,KAAK,CAACkH,cAAc,CAAC,CAAC;cACtB,MAAM5F,KAAK,GAAGN,WAAW,CAACO,SAAS,CAACC,KAAK,IAAIA,KAAK,CAAC/E,OAAO,CAACW,EAAE,KAAK8C,QAAQ,CAAC;cAC3E,IAAIoB,KAAK,IAAI,CAAC,EAAE;gBACd,MAAMkE,SAAS,GAAGxE,WAAW,CAACM,KAAK,CAAC;gBACpC,MAAM1C,IAAI,GAAGiC,KAAK,CAACS,KAAK,CAAC;gBACzB,IAAI1C,IAAI,IAAI,IAAI,EAAE;kBAChB,IAAIuI,KAAK,GAAG,CAAC;kBACb,IAAIvI,IAAI,CAACoD,WAAW,CAAClC,SAAS,CAAC,IAAI0F,SAAS,CAAC/I,OAAO,CAACc,OAAO,CAACyE,WAAW,CAAClC,SAAS,CAAC,EAAE;oBACnFqH,KAAK,GAAG7D,SAAS,KAAK,YAAY,GAAG4C,KAAK,GAAGD,MAAM;kBACrD,CAAC,MAAM;oBACLkB,KAAK,GAAG,EAAE7D,SAAS,KAAK,YAAY,GAAG4C,KAAK,GAAGD,MAAM,CAAC;kBACxD;kBACA,MAAM/E,SAAS,GAAGnB,aAAa,CAACC,KAAK,EAAErB,kBAAkB,CAAClC,OAAO,EAAEyD,QAAQ,EAAEC,OAAO,EAAEgH,KAAK,EAAEtG,KAAK,EAAEP,uBAAuB,CAAC7D,OAAO,EAAE,IAAI,CAAC;kBAC1I,IAAIoE,KAAK,KAAKK,SAAS,EAAE;oBACvB6E,QAAQ,CAAC7E,SAAS,CAAC;kBACrB;gBACF;cACF;cACA;YACF;QACJ;MACF,CAAC;MACD2C,MAAM,CAACuD,gBAAgB,CAAC,SAAS,EAAEL,SAAS,CAAC;MAC7C,MAAMM,WAAW,GAAGrD,QAAQ,CAAC9D,QAAQ,CAAC;MACtC,IAAImH,WAAW,IAAI,IAAI,EAAE;QACvBxD,MAAM,CAAC+C,YAAY,CAAC,eAAe,EAAES,WAAW,CAACjK,EAAE,CAAC;MACtD;MACA,OAAO,MAAM;QACXyG,MAAM,CAACyD,eAAe,CAAC,eAAe,CAAC;QACvCzD,MAAM,CAACyD,eAAe,CAAC,eAAe,CAAC;QACvCzD,MAAM,CAACyD,eAAe,CAAC,eAAe,CAAC;QACvCzD,MAAM,CAAC0D,mBAAmB,CAAC,SAAS,EAAER,SAAS,CAAC;QAChD,IAAIM,WAAW,IAAI,IAAI,EAAE;UACvBxD,MAAM,CAACyD,eAAe,CAAC,eAAe,CAAC;QACzC;MACF,CAAC;IACH,CAAC,CAAC;IACF,OAAO,MAAM;MACXlB,gBAAgB,CAAC9D,OAAO,CAACkF,eAAe,IAAIA,eAAe,CAAC,CAAC,CAAC;IAChE,CAAC;EACH,CAAC,EAAE,CAAC7I,kBAAkB,EAAE6B,OAAO,EAAEC,MAAM,EAAEH,uBAAuB,EAAEyF,QAAQ,EAAElF,KAAK,CAAC,CAAC;AACrF;AACA,SAAS4G,sCAAsCA,CAAC;EAC9CC,QAAQ;EACR/C,QAAQ;EACRgD;AACF,CAAC,EAAE;EACDjM,SAAS,CAAC,MAAM;IACd,IAAIgM,QAAQ,IAAIC,aAAa,IAAI,IAAI,EAAE;MACrC;IACF;IACA,MAAMC,aAAa,GAAGxD,eAAe,CAACO,QAAQ,CAAC;IAC/C,IAAIiD,aAAa,IAAI,IAAI,EAAE;MACzB;IACF;IACA,MAAMb,SAAS,GAAG/G,KAAK,IAAI;MACzB,IAAIA,KAAK,CAACgH,gBAAgB,EAAE;QAC1B;MACF;MACA,QAAQhH,KAAK,CAACiH,GAAG;QACf,KAAK,WAAW;QAChB,KAAK,WAAW;QAChB,KAAK,YAAY;QACjB,KAAK,SAAS;QACd,KAAK,KAAK;QACV,KAAK,MAAM;UACT;YACEjH,KAAK,CAACkH,cAAc,CAAC,CAAC;YACtBS,aAAa,CAAC3H,KAAK,CAAC;YACpB;UACF;QACF,KAAK,IAAI;UACP;YACEA,KAAK,CAACkH,cAAc,CAAC,CAAC;YACtB,MAAM5C,OAAO,GAAGC,gBAAgB,CAAC,CAAC;YAClC,MAAMjD,KAAK,GAAG+C,oBAAoB,CAACM,QAAQ,CAAC;YAC5CgB,MAAM,CAACrE,KAAK,KAAK,IAAI,CAAC;YACtB,MAAMuG,SAAS,GAAG7H,KAAK,CAAC8H,QAAQ,GAAGxG,KAAK,GAAG,CAAC,GAAGA,KAAK,GAAG,CAAC,GAAGgD,OAAO,CAACnC,MAAM,GAAG,CAAC,GAAGb,KAAK,GAAG,CAAC,GAAGgD,OAAO,CAACnC,MAAM,GAAGb,KAAK,GAAG,CAAC,GAAG,CAAC;YAC1H,MAAMyG,UAAU,GAAGzD,OAAO,CAACuD,SAAS,CAAC;YACrCE,UAAU,CAACC,KAAK,CAAC,CAAC;YAClB;UACF;MACJ;IACF,CAAC;IACDJ,aAAa,CAACR,gBAAgB,CAAC,SAAS,EAAEL,SAAS,CAAC;IACpD,OAAO,MAAM;MACXa,aAAa,CAACL,mBAAmB,CAAC,SAAS,EAAER,SAAS,CAAC;IACzD,CAAC;EACH,CAAC,EAAE,CAACW,QAAQ,EAAE/C,QAAQ,EAAEgD,aAAa,CAAC,CAAC;AACzC;AAEA,SAASM,QAAQA,CAACC,MAAM,EAAEC,MAAM,EAAE;EAChC,IAAID,MAAM,CAAC/F,MAAM,KAAKgG,MAAM,CAAChG,MAAM,EAAE;IACnC,OAAO,KAAK;EACd;EACA,KAAK,IAAIb,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG4G,MAAM,CAAC/F,MAAM,EAAEb,KAAK,EAAE,EAAE;IAClD,IAAI4G,MAAM,CAAC5G,KAAK,CAAC,KAAK6G,MAAM,CAAC7G,KAAK,CAAC,EAAE;MACnC,OAAO,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb;AAEA,SAAS8G,aAAaA,CAACpI,KAAK,EAAE2E,QAAQ,EAAErB,SAAS,EAAE+E,aAAa,GAAG,CAAC,EAAEC,wBAAwB,GAAG,IAAI,EAAE;EACrG,MAAMC,YAAY,GAAGjF,SAAS,KAAK,YAAY;EAC/C,IAAIkF,aAAa,GAAG,CAAC;EACrB,IAAIC,YAAY,CAACzI,KAAK,CAAC,EAAE;IACvBwI,aAAa,GAAGD,YAAY,GAAGvI,KAAK,CAAC0I,OAAO,GAAG1I,KAAK,CAAC2I,OAAO;EAC9D,CAAC,MAAM,IAAIC,YAAY,CAAC5I,KAAK,CAAC,EAAE;IAC9B,MAAM6I,UAAU,GAAG7I,KAAK,CAAC8I,OAAO,CAAC,CAAC,CAAC;IACnCN,aAAa,GAAGD,YAAY,GAAGM,UAAU,CAACE,OAAO,GAAGF,UAAU,CAACG,OAAO;EACxE,CAAC,MAAM;IACL,OAAO,CAAC;EACV;EACA,MAAMpB,aAAa,GAAGxD,eAAe,CAACO,QAAQ,CAAC;EAC/C,MAAMsE,IAAI,GAAGX,wBAAwB,IAAIV,aAAa,CAACzB,qBAAqB,CAAC,CAAC;EAC9E,MAAM+C,aAAa,GAAGX,YAAY,GAAGU,IAAI,CAACE,IAAI,GAAGF,IAAI,CAACG,GAAG;EACzD,OAAOZ,aAAa,GAAGU,aAAa,GAAGb,aAAa;AACtD;;AAEA;AACA,SAASgB,WAAWA,CAACrJ,KAAK,EAAEQ,OAAO,EAAEmE,QAAQ,EAAE3D,WAAW,EAAEsC,SAAS,EAAEjD,SAAS,EAAEE,gBAAgB,EAAE;EAClG,MAAM;IACJ+I,UAAU,GAAG,CAAC;IACdC,cAAc;IACd1I,KAAK,EAAEC;EACT,CAAC,GAAGP,gBAAgB,IAAI,CAAC,CAAC;;EAE1B;EACA;EACA,MAAMQ,SAAS,GAAGD,YAAY,IAAIT,SAAS;EAC3C,IAAImJ,SAAS,CAACxJ,KAAK,CAAC,EAAE;IACpB,MAAMuI,YAAY,GAAGjF,SAAS,KAAK,YAAY;IAC/C,MAAM0C,YAAY,GAAG3C,aAAa,CAAC7C,OAAO,CAAC;IAC3C,MAAMyI,IAAI,GAAGjD,YAAY,CAACG,qBAAqB,CAAC,CAAC;IACjD,MAAMsD,iBAAiB,GAAGlB,YAAY,GAAGU,IAAI,CAAC/C,KAAK,GAAG+C,IAAI,CAAChD,MAAM;IACjE,MAAMyD,WAAW,GAAG1J,KAAK,CAAC8H,QAAQ,GAAG,EAAE,GAAG,GAAG;IAC7C,MAAMX,KAAK,GAAGsC,iBAAiB,GAAGC,WAAW;IAC7C,IAAIC,QAAQ,GAAG,CAAC;IAChB,QAAQ3J,KAAK,CAACiH,GAAG;MACf,KAAK,WAAW;QACd0C,QAAQ,GAAGpB,YAAY,GAAG,CAAC,GAAGpB,KAAK;QACnC;MACF,KAAK,WAAW;QACdwC,QAAQ,GAAGpB,YAAY,GAAG,CAACpB,KAAK,GAAG,CAAC;QACpC;MACF,KAAK,YAAY;QACfwC,QAAQ,GAAGpB,YAAY,GAAGpB,KAAK,GAAG,CAAC;QACnC;MACF,KAAK,SAAS;QACZwC,QAAQ,GAAGpB,YAAY,GAAG,CAAC,GAAG,CAACpB,KAAK;QACpC;MACF,KAAK,KAAK;QACRwC,QAAQ,GAAGF,iBAAiB;QAC5B;MACF,KAAK,MAAM;QACTE,QAAQ,GAAG,CAACF,iBAAiB;QAC7B;IACJ;;IAEA;IACA;IACA;IACA;IACA,MAAM,CAACvJ,QAAQ,EAAEC,OAAO,CAAC,GAAGuE,uBAAuB,CAAClE,OAAO,EAAEmE,QAAQ,EAAE3D,WAAW,CAAC;IACnF,MAAM4I,aAAa,GAAGD,QAAQ,GAAG,CAAC,GAAGzJ,QAAQ,GAAGC,OAAO;IACvD,MAAM0J,gBAAgB,GAAG7I,WAAW,CAACO,SAAS,CAACC,KAAK,IAAIA,KAAK,CAAC/E,OAAO,CAACW,EAAE,KAAKwM,aAAa,CAAC;IAC3F,MAAME,WAAW,GAAG9I,WAAW,CAAC6I,gBAAgB,CAAC;IACjD,IAAIC,WAAW,CAACrN,OAAO,CAACQ,WAAW,EAAE;MACnC,MAAMwE,QAAQ,GAAGV,SAAS,CAAC8I,gBAAgB,CAAC;MAC5C,IAAIpI,QAAQ,KAAK,CAAC,IAAIA,QAAQ,CAACO,WAAW,CAAClC,SAAS,CAAC,KAAKgK,WAAW,CAACrN,OAAO,CAACc,OAAO,CAACyE,WAAW,CAAClC,SAAS,CAAC,EAAE;QAC5G6J,QAAQ,GAAGA,QAAQ,GAAG,CAAC,GAAG,CAACG,WAAW,CAACrN,OAAO,CAACc,OAAO,GAAGkM,iBAAiB,GAAGK,WAAW,CAACrN,OAAO,CAACc,OAAO,GAAGkM,iBAAiB;MAC9H;IACF;IACA,OAAOE,QAAQ;EACjB,CAAC,MAAM;IACL,OAAOvB,aAAa,CAACpI,KAAK,EAAE2E,QAAQ,EAAErB,SAAS,EAAEgG,UAAU,EAAEC,cAAc,CAAC;EAC9E;AACF;AACA,SAASC,SAASA,CAACxJ,KAAK,EAAE;EACxB,OAAOA,KAAK,CAACqF,IAAI,KAAK,SAAS;AACjC;AACA,SAASoD,YAAYA,CAACzI,KAAK,EAAE;EAC3B,OAAOA,KAAK,CAACqF,IAAI,CAACC,UAAU,CAAC,OAAO,CAAC;AACvC;AACA,SAASsD,YAAYA,CAAC5I,KAAK,EAAE;EAC3B,OAAOA,KAAK,CAACqF,IAAI,CAACC,UAAU,CAAC,OAAO,CAAC;AACvC;AAEA,IAAIyE,YAAY,GAAG,IAAI;AACvB,IAAI9F,OAAO,GAAG,IAAI;AAClB,SAAS+F,cAAcA,CAACC,KAAK,EAAE;EAC7B,QAAQA,KAAK;IACX,KAAK,YAAY;MACf,OAAO,WAAW;IACpB,KAAK,gBAAgB;MACnB,OAAO,UAAU;IACnB,KAAK,gBAAgB;MACnB,OAAO,UAAU;IACnB,KAAK,UAAU;MACb,OAAO,WAAW;IACpB,KAAK,cAAc;MACjB,OAAO,UAAU;IACnB,KAAK,cAAc;MACjB,OAAO,UAAU;EACrB;AACF;AACA,SAASC,sBAAsBA,CAAA,EAAG;EAChC,IAAIjG,OAAO,KAAK,IAAI,EAAE;IACpBC,QAAQ,CAACiG,IAAI,CAACC,WAAW,CAACnG,OAAO,CAAC;IAClC8F,YAAY,GAAG,IAAI;IACnB9F,OAAO,GAAG,IAAI;EAChB;AACF;AACA,SAASoG,oBAAoBA,CAACJ,KAAK,EAAE;EACnC,IAAIF,YAAY,KAAKE,KAAK,EAAE;IAC1B;EACF;EACAF,YAAY,GAAGE,KAAK;EACpB,MAAMtM,KAAK,GAAGqM,cAAc,CAACC,KAAK,CAAC;EACnC,IAAIhG,OAAO,KAAK,IAAI,EAAE;IACpBA,OAAO,GAAGC,QAAQ,CAAC7I,aAAa,CAAC,OAAO,CAAC;IACzC6I,QAAQ,CAACiG,IAAI,CAACG,WAAW,CAACrG,OAAO,CAAC;EACpC;EACAA,OAAO,CAACsG,SAAS,GAAI,aAAY5M,KAAM,cAAa;AACtD;AAEA,SAAS6M,QAAQA,CAACC,QAAQ,EAAEC,UAAU,GAAG,EAAE,EAAE;EAC3C,IAAIC,SAAS,GAAG,IAAI;EACpB,IAAIC,QAAQ,GAAGA,CAAC,GAAGC,IAAI,KAAK;IAC1B,IAAIF,SAAS,KAAK,IAAI,EAAE;MACtBG,YAAY,CAACH,SAAS,CAAC;IACzB;IACAA,SAAS,GAAGI,UAAU,CAAC,MAAM;MAC3BN,QAAQ,CAAC,GAAGI,IAAI,CAAC;IACnB,CAAC,EAAEH,UAAU,CAAC;EAChB,CAAC;EACD,OAAOE,QAAQ;AACjB;;AAEA;AACA;AACA;AACA;AACA,SAASI,mBAAmBA,CAACvK,MAAM,EAAE;EACnC,OAAOA,MAAM,CAAC4F,GAAG,CAAC7E,KAAK,IAAI;IACzB,MAAM;MACJjE,OAAO;MACPG;IACF,CAAC,GAAG8D,KAAK,CAAC/E,OAAO;IACjB,OAAOiB,KAAK,GAAI,GAAEA,KAAM,IAAGH,OAAQ,EAAC,GAAI,GAAEA,OAAQ,EAAC;EACrD,CAAC,CAAC,CAACuH,IAAI,CAAC,CAACmG,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAAChJ,aAAa,CAACiJ,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;AACjD;AACA,SAASC,6BAA6BA,CAACC,UAAU,EAAEC,OAAO,EAAE;EAC1D,IAAI;IACF,MAAMC,UAAU,GAAGD,OAAO,CAACE,OAAO,CAAE,oBAAmBH,UAAW,EAAC,CAAC;IACpE,IAAIE,UAAU,EAAE;MACd,MAAME,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACJ,UAAU,CAAC;MACrC,IAAI,OAAOE,MAAM,KAAK,QAAQ,IAAIA,MAAM,IAAI,IAAI,EAAE;QAChD,OAAOA,MAAM;MACf;IACF;EACF,CAAC,CAAC,OAAOxI,KAAK,EAAE,CAAC;EACjB,OAAO,IAAI;AACb;AACA,SAAS2I,eAAeA,CAACP,UAAU,EAAE5K,MAAM,EAAE6K,OAAO,EAAE;EACpD,MAAMrB,KAAK,GAAGmB,6BAA6B,CAACC,UAAU,EAAEC,OAAO,CAAC;EAChE,IAAIrB,KAAK,EAAE;IACT,MAAMhD,GAAG,GAAG+D,mBAAmB,CAACvK,MAAM,CAAC;IACvC,OAAOwJ,KAAK,CAAChD,GAAG,CAAC,IAAI,IAAI;EAC3B;EACA,OAAO,IAAI;AACb;AACA,SAAS4E,oBAAoBA,CAACR,UAAU,EAAE5K,MAAM,EAAEI,KAAK,EAAEyK,OAAO,EAAE;EAChE,MAAMrE,GAAG,GAAG+D,mBAAmB,CAACvK,MAAM,CAAC;EACvC,MAAMwJ,KAAK,GAAGmB,6BAA6B,CAACC,UAAU,EAAEC,OAAO,CAAC,IAAI,CAAC,CAAC;EACtErB,KAAK,CAAChD,GAAG,CAAC,GAAGpG,KAAK;EAClB,IAAI;IACFyK,OAAO,CAACQ,OAAO,CAAE,oBAAmBT,UAAW,EAAC,EAAEK,IAAI,CAACK,SAAS,CAAC9B,KAAK,CAAC,CAAC;EAC1E,CAAC,CAAC,OAAOhH,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAACA,KAAK,CAAC;EACtB;AACF;AAEA,MAAM+I,WAAW,GAAG,CAAC,CAAC;;AAEtB;AACA;AACA;AACA;AACA,SAASC,wBAAwBA,CAACC,aAAa,EAAE;EAC/C,IAAI;IACF,IAAI,OAAOC,YAAY,KAAK,WAAW,EAAE;MACvC;MACAD,aAAa,CAACV,OAAO,GAAGY,IAAI,IAAI;QAC9B,OAAOD,YAAY,CAACX,OAAO,CAACY,IAAI,CAAC;MACnC,CAAC;MACDF,aAAa,CAACJ,OAAO,GAAG,CAACM,IAAI,EAAEC,KAAK,KAAK;QACvCF,YAAY,CAACL,OAAO,CAACM,IAAI,EAAEC,KAAK,CAAC;MACnC,CAAC;IACH,CAAC,MAAM;MACL,MAAM,IAAIrO,KAAK,CAAC,gDAAgD,CAAC;IACnE;EACF,CAAC,CAAC,OAAOiF,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAACA,KAAK,CAAC;IACpBiJ,aAAa,CAACV,OAAO,GAAG,MAAM,IAAI;IAClCU,aAAa,CAACJ,OAAO,GAAG,MAAM,CAAC,CAAC;EAClC;AACF;AACA,MAAMQ,cAAc,GAAG;EACrBd,OAAO,EAAEY,IAAI,IAAI;IACfH,wBAAwB,CAACK,cAAc,CAAC;IACxC,OAAOA,cAAc,CAACd,OAAO,CAACY,IAAI,CAAC;EACrC,CAAC;EACDN,OAAO,EAAEA,CAACM,IAAI,EAAEC,KAAK,KAAK;IACxBJ,wBAAwB,CAACK,cAAc,CAAC;IACxCA,cAAc,CAACR,OAAO,CAACM,IAAI,EAAEC,KAAK,CAAC;EACrC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,0BAA0BA,CAAC;EAClClB,UAAU;EACVxO,QAAQ,GAAG,IAAI;EACfC,SAAS,EAAEC,kBAAkB,GAAG,EAAE;EAClCuG,SAAS;EACTkJ,gCAAgC,GAAG,KAAK;EACxCrP,YAAY;EACZC,EAAE,EAAEC,WAAW,GAAG,IAAI;EACtBoP,QAAQ;EACRnB,OAAO,GAAGgB,cAAc;EACxB3O,KAAK,EAAEC,cAAc,GAAG,CAAC,CAAC;EAC1BC,OAAO,EAAEC,IAAI,GAAG,KAAK;EACrBU,KAAK,GAAG;AACV,CAAC,EAAE;EACD,MAAMgC,OAAO,GAAGnE,WAAW,CAACgB,WAAW,CAAC;EACxC,MAAM,CAACqP,cAAc,EAAEC,iBAAiB,CAAC,GAAG5Q,QAAQ,CAAC,IAAI,CAAC;EAC1D,MAAM,CAAC0E,MAAM,EAAEmM,SAAS,CAAC,GAAG7Q,QAAQ,CAAC,IAAI8Q,GAAG,CAAC,CAAC,CAAC;;EAE/C;EACA;EACA;EACA,MAAMC,mBAAmB,GAAGhR,MAAM,CAAC,IAAI,CAAC;EACxC,MAAMiR,cAAc,GAAGjR,MAAM,CAAC;IAC5BkR,wBAAwB,EAAE,KAAK;IAC/BC,uBAAuB,EAAE,KAAK;IAC9BC,0BAA0B,EAAE,KAAK;IACjCC,YAAY,EAAE;EAChB,CAAC,CAAC;;EAEF;EACA,MAAMzO,YAAY,GAAG5C,MAAM,CAAC;IAC1B2Q;EACF,CAAC,CAAC;EACF/Q,SAAS,CAAC,MAAM;IACdgD,YAAY,CAACjC,OAAO,CAACgQ,QAAQ,GAAGA,QAAQ;EAC1C,CAAC,CAAC;EACF,MAAMW,+BAA+B,GAAGtR,MAAM,CAAC,CAAC,CAAC,CAAC;;EAElD;EACA,MAAM,CAAC+E,KAAK,EAAEkF,QAAQ,CAAC,GAAGhK,QAAQ,CAAC,EAAE,CAAC;;EAEtC;EACA,MAAMuE,uBAAuB,GAAGxE,MAAM,CAAC,IAAI+Q,GAAG,CAAC,CAAC,CAAC;EACjD,MAAMQ,YAAY,GAAGvR,MAAM,CAAC,CAAC,CAAC;;EAE9B;EACA,MAAM6C,kBAAkB,GAAG7C,MAAM,CAAC;IAChCwH,SAAS;IACTlG,EAAE,EAAEoD,OAAO;IACXC,MAAM;IACNI,KAAK;IACLrC;EACF,CAAC,CAAC;EACF7C,mBAAmB,CAACwB,YAAY,EAAE,OAAO;IACvCgC,KAAK,EAAEA,CAAA,KAAMqB,OAAO;IACpB8M,SAAS,EAAEC,eAAe,IAAI;MAC5B,MAAM;QACJ1M,KAAK;QACLrC,KAAK,EAAEgP;MACT,CAAC,GAAG7O,kBAAkB,CAAClC,OAAO;MAC9B,MAAM+B,KAAK,GAAG+O,eAAe,IAAIC,cAAc;MAC/C,IAAIhP,KAAK,KAAK,QAAQ,EAAE;QACtB,MAAMkC,eAAe,GAAGC,2BAA2B,CAACH,OAAO,CAAC;QAC5D,OAAOK,KAAK,CAACwF,GAAG,CAACzH,IAAI,IAAIA,IAAI,GAAG,GAAG,GAAG8B,eAAe,CAAC;MACxD,CAAC,MAAM;QACL,OAAOG,KAAK;MACd;IACF,CAAC;IACD4M,SAAS,EAAEA,CAAC5M,KAAK,EAAE0M,eAAe,KAAK;MACrC,MAAM;QACJnQ,EAAE,EAAEoD,OAAO;QACXC,MAAM;QACNI,KAAK,EAAER,SAAS;QAChB7B;MACF,CAAC,GAAGG,kBAAkB,CAAClC,OAAO;MAC9B,IAAI,CAAC8Q,eAAe,IAAI/O,KAAK,MAAM,QAAQ,EAAE;QAC3C,MAAMkC,eAAe,GAAGC,2BAA2B,CAACH,OAAO,CAAC;QAC5DK,KAAK,GAAGA,KAAK,CAACwF,GAAG,CAACzH,IAAI,IAAIA,IAAI,GAAG8B,eAAe,GAAG,GAAG,CAAC;MACzD;MACA,MAAM2B,4BAA4B,GAAG+K,+BAA+B,CAAC3Q,OAAO;MAC5E,MAAMuE,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;MAClD,MAAMS,SAAS,GAAGuE,wBAAwB,CAAC;QACzCjF,OAAO;QACPC,MAAM;QACNS,SAAS,EAAEL,KAAK;QAChBR,SAAS;QACT7B;MACF,CAAC,CAAC;MACF,IAAI,CAACyJ,QAAQ,CAAC5H,SAAS,EAAEa,SAAS,CAAC,EAAE;QACnC6E,QAAQ,CAAC7E,SAAS,CAAC;QACnBkB,kBAAkB,CAACpB,WAAW,EAAEE,SAAS,EAAEmB,4BAA4B,CAAC;MAC1E;IACF;EACF,CAAC,CAAC,EAAE,CAAC7B,OAAO,CAAC,CAAC;EACdtE,yBAAyB,CAAC,MAAM;IAC9ByC,kBAAkB,CAAClC,OAAO,CAAC6G,SAAS,GAAGA,SAAS;IAChD3E,kBAAkB,CAAClC,OAAO,CAACW,EAAE,GAAGoD,OAAO;IACvC7B,kBAAkB,CAAClC,OAAO,CAACgE,MAAM,GAAGA,MAAM;IAC1C9B,kBAAkB,CAAClC,OAAO,CAACoE,KAAK,GAAGA,KAAK;IACxClC,kBAAkB,CAAClC,OAAO,CAAC+B,KAAK,GAAGA,KAAK;EAC1C,CAAC,CAAC;EACFsH,mCAAmC,CAAC;IAClCnH,kBAAkB;IAClB6B,OAAO;IACPC,MAAM;IACNsF,QAAQ;IACRlF,KAAK;IACLP;EACF,CAAC,CAAC;;EAEF;EACA5E,SAAS,CAAC,MAAM;IACd,MAAM;MACJ+Q;IACF,CAAC,GAAG/N,YAAY,CAACjC,OAAO;IACxB,MAAM;MACJgE,MAAM;MACNI;IACF,CAAC,GAAGlC,kBAAkB,CAAClC,OAAO;;IAE9B;IACA,IAAIoE,KAAK,CAACsB,MAAM,GAAG,CAAC,EAAE;MACpB,IAAIsK,QAAQ,EAAE;QACZA,QAAQ,CAAC5L,KAAK,CAAC;MACjB;MACA,MAAMwB,4BAA4B,GAAG+K,+BAA+B,CAAC3Q,OAAO;;MAE5E;MACA;MACA;MACA;MACA;MACA,MAAMuE,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;MAClD2B,kBAAkB,CAACpB,WAAW,EAAEH,KAAK,EAAEwB,4BAA4B,CAAC;IACtE;EACF,CAAC,EAAE,CAACxB,KAAK,CAAC,CAAC;;EAEX;EACA;EACA;EACA3E,yBAAyB,CAAC,MAAM;IAC9B,MAAM;MACJkB,EAAE,EAAEoD,OAAO;MACXK,KAAK;MACLrC;IACF,CAAC,GAAGG,kBAAkB,CAAClC,OAAO;IAC9B,IAAIoE,KAAK,CAACsB,MAAM,KAAK1B,MAAM,CAAC7B,IAAI,EAAE;MAChC;MACA;IACF;;IAEA;IACA;IACA,IAAI8O,YAAY,GAAG,IAAI;IACvB,IAAIrC,UAAU,EAAE;MACd,MAAMrK,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;MAClDiN,YAAY,GAAG9B,eAAe,CAACP,UAAU,EAAErK,WAAW,EAAEsK,OAAO,CAAC;IAClE;IACA,IAAIoC,YAAY,IAAI,IAAI,EAAE;MACxB;MACA;MACA,MAAMC,cAAc,GAAGlI,wBAAwB,CAAC;QAC9CjF,OAAO;QACPC,MAAM;QACNS,SAAS,EAAEwM,YAAY;QACvBrN,SAAS,EAAEqN,YAAY;QACvBlP;MACF,CAAC,CAAC;MACFuH,QAAQ,CAAC4H,cAAc,CAAC;IAC1B,CAAC,MAAM;MACL,MAAM9M,KAAK,GAAG4B,sBAAsB,CAAC;QACnCjC,OAAO;QACPC,MAAM;QACNjC;MACF,CAAC,CAAC;MACFuH,QAAQ,CAAClF,KAAK,CAAC;IACjB;EACF,CAAC,EAAE,CAACwK,UAAU,EAAE5K,MAAM,EAAE6K,OAAO,CAAC,CAAC;EACjC5P,SAAS,CAAC,MAAM;IACd;IACA,IAAI2P,UAAU,EAAE;MACd,IAAIxK,KAAK,CAACsB,MAAM,KAAK,CAAC,IAAItB,KAAK,CAACsB,MAAM,KAAK1B,MAAM,CAAC7B,IAAI,EAAE;QACtD;MACF;MACA,MAAMoC,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;;MAElD;MACA,IAAI,CAACuL,WAAW,CAACX,UAAU,CAAC,EAAE;QAC5BW,WAAW,CAACX,UAAU,CAAC,GAAGb,QAAQ,CAACqB,oBAAoB,EAAE,GAAG,CAAC;MAC/D;MACAG,WAAW,CAACX,UAAU,CAAC,CAACA,UAAU,EAAErK,WAAW,EAAEH,KAAK,EAAEyK,OAAO,CAAC;IAClE;IACA;MACE,MAAM;QACJ2B,uBAAuB;QACvBE;MACF,CAAC,GAAGJ,cAAc,CAACtQ,OAAO;MAC1B,IAAI,CAACwQ,uBAAuB,EAAE;QAC5B,MAAM;UACJxM;QACF,CAAC,GAAG9B,kBAAkB,CAAClC,OAAO;QAC9B,MAAMmR,QAAQ,GAAGlL,KAAK,CAAC8B,IAAI,CAAC/D,MAAM,CAACoN,IAAI,CAAC,CAAC,CAAC;QAC1Cd,cAAc,CAACtQ,OAAO,CAAC0Q,YAAY,GAAGS,QAAQ;QAC9C,MAAME,iBAAiB,GAAGX,YAAY,CAAChL,MAAM,GAAG,CAAC,IAAI,CAAC8F,QAAQ,CAACkF,YAAY,EAAES,QAAQ,CAAC;QACtF,IAAIE,iBAAiB,EAAE;UACrB,IAAIpL,KAAK,CAAC8B,IAAI,CAAC/D,MAAM,CAACoE,MAAM,CAAC,CAAC,CAAC,CAACkJ,IAAI,CAACvM,KAAK,IAAIA,KAAK,CAAC/E,OAAO,CAACsC,kBAAkB,IAAIyC,KAAK,CAAC/E,OAAO,CAACiB,KAAK,IAAI,IAAI,CAAC,EAAE;YAC9GqP,cAAc,CAACtQ,OAAO,CAACwQ,uBAAuB,GAAG,IAAI;YACrDjK,OAAO,CAACgL,IAAI,CAAE,oFAAmF,CAAC;UACpG;QACF;MACF;IACF;EACF,CAAC,EAAE,CAAC3C,UAAU,EAAE5K,MAAM,EAAEI,KAAK,EAAEyK,OAAO,CAAC,CAAC;EACxCpP,yBAAyB,CAAC,MAAM;IAC9B;IACA;IACA,IAAIsC,KAAK,KAAK,QAAQ,EAAE;MACtB,MAAMyP,cAAc,GAAG,IAAIC,cAAc,CAAC,MAAM;QAC9C,MAAM;UACJzN,MAAM;UACNI,KAAK,EAAER;QACT,CAAC,GAAG1B,kBAAkB,CAAClC,OAAO;QAC9B,MAAMyE,SAAS,GAAGuE,wBAAwB,CAAC;UACzCjF,OAAO;UACPC,MAAM;UACNS,SAAS,EAAEb,SAAS;UACpBA,SAAS;UACT7B;QACF,CAAC,CAAC;QACF,IAAI,CAACyJ,QAAQ,CAAC5H,SAAS,EAAEa,SAAS,CAAC,EAAE;UACnC6E,QAAQ,CAAC7E,SAAS,CAAC;QACrB;MACF,CAAC,CAAC;MACF+M,cAAc,CAACE,OAAO,CAAC9K,aAAa,CAAC7C,OAAO,CAAC,CAAC;MAC9C,OAAO,MAAM;QACXyN,cAAc,CAACG,UAAU,CAAC,CAAC;MAC7B,CAAC;IACH;EACF,CAAC,EAAE,CAAC5N,OAAO,EAAEhC,KAAK,CAAC,CAAC;EACpB,MAAMJ,YAAY,GAAG5C,WAAW,CAAC,CAAC4B,EAAE,EAAEmQ,eAAe,KAAK;IACxD,MAAM;MACJ9M,MAAM;MACNjC,KAAK,EAAEgP;IACT,CAAC,GAAG7O,kBAAkB,CAAClC,OAAO;IAC9B,MAAMuE,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;IAClD,MAAMa,KAAK,GAAGN,WAAW,CAACO,SAAS,CAACC,KAAK,IAAIA,KAAK,CAAC/E,OAAO,CAACW,EAAE,KAAKA,EAAE,CAAC;IACrE,MAAMwB,IAAI,GAAGiC,KAAK,CAACS,KAAK,CAAC;IACzB,MAAM9C,KAAK,GAAG+O,eAAe,IAAIC,cAAc;IAC/C,IAAIhP,KAAK,KAAK,QAAQ,EAAE;MACtB,MAAMkC,eAAe,GAAGC,2BAA2B,CAACH,OAAO,CAAC;MAC5D,OAAO5B,IAAI,GAAG,GAAG,GAAG8B,eAAe;IACrC,CAAC,MAAM;MACL,OAAO9B,IAAI;IACb;EACF,CAAC,EAAE,CAAC4B,OAAO,EAAEK,KAAK,CAAC,CAAC;EACpB,MAAMxC,aAAa,GAAG7C,WAAW,CAAC,CAAC4B,EAAE,EAAEF,WAAW,KAAK;IACrD,MAAM;MACJuD;IACF,CAAC,GAAG9B,kBAAkB,CAAClC,OAAO;;IAE9B;IACA;IACA;IACA,IAAIgE,MAAM,CAAC7B,IAAI,KAAK,CAAC,EAAE;MACrB;QACE,IAAI,CAACmO,cAAc,CAACtQ,OAAO,CAACuQ,wBAAwB,EAAE;MACxD;MACA,OAAO;QACLqB,SAAS,EAAE,CAAC;QACZ5O,QAAQ,EAAEvC,WAAW,IAAI,IAAI,GAAGA,WAAW,GAAGqC,SAAS;QACvD+O,UAAU,EAAE,CAAC;QACb;QACAC,QAAQ,EAAE;MACZ,CAAC;IACH;IACA,MAAM9O,QAAQ,GAAGsE,WAAW,CAACtD,MAAM,EAAErD,EAAE,EAAEyD,KAAK,CAAC;IAC/C,OAAO;MACLwN,SAAS,EAAE,CAAC;MACZ5O,QAAQ;MACR6O,UAAU,EAAE,CAAC;MACb;MACAC,QAAQ,EAAE,QAAQ;MAClB;MACA;MACAC,aAAa,EAAEhC,gCAAgC,IAAIE,cAAc,KAAK,IAAI,GAAG,MAAM,GAAGnN;IACxF,CAAC;EACH,CAAC,EAAE,CAACmN,cAAc,EAAEF,gCAAgC,EAAE3L,KAAK,CAAC,CAAC;EAC7D,MAAMvC,aAAa,GAAG9C,WAAW,CAAC,CAAC4B,EAAE,EAAEmF,QAAQ,KAAK;IAClD,MAAM;MACJ/D;IACF,CAAC,GAAGG,kBAAkB,CAAClC,OAAO;IAC9B8I,kBAAkB,CAAC/G,KAAK,EAAE+D,QAAQ,CAAC;IACnCqK,SAAS,CAAC6B,UAAU,IAAI;MACtB,IAAIA,UAAU,CAACC,GAAG,CAACtR,EAAE,CAAC,EAAE;QACtB,OAAOqR,UAAU;MACnB;MACA,MAAME,UAAU,GAAG,IAAI9B,GAAG,CAAC4B,UAAU,CAAC;MACtCE,UAAU,CAAC7M,GAAG,CAAC1E,EAAE,EAAEmF,QAAQ,CAAC;MAC5B,OAAOoM,UAAU;IACnB,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;EACN,MAAMC,oBAAoB,GAAGpT,WAAW,CAACmJ,QAAQ,IAAI;IACnD,MAAMgD,aAAa,GAAG3H,KAAK,IAAI;MAC7BA,KAAK,CAACkH,cAAc,CAAC,CAAC;MACtB,MAAM;QACJ5D,SAAS;QACT7C,MAAM;QACNI,KAAK,EAAER;MACT,CAAC,GAAG1B,kBAAkB,CAAClC,OAAO;MAC9B,MAAMuE,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;MAClD,MAAM,CAACP,QAAQ,EAAEC,OAAO,CAAC,GAAGuE,uBAAuB,CAAClE,OAAO,EAAEmE,QAAQ,EAAE3D,WAAW,CAAC;MACnF,IAAId,QAAQ,IAAI,IAAI,IAAIC,OAAO,IAAI,IAAI,EAAE;QACvC;MACF;MACA,IAAIwJ,QAAQ,GAAGN,WAAW,CAACrJ,KAAK,EAAEQ,OAAO,EAAEmE,QAAQ,EAAE3D,WAAW,EAAEsC,SAAS,EAAEjD,SAAS,EAAEyM,mBAAmB,CAACrQ,OAAO,CAAC;MACpH,IAAIkN,QAAQ,KAAK,CAAC,EAAE;QAClB;MACF;MACA,MAAM3D,YAAY,GAAG3C,aAAa,CAAC7C,OAAO,CAAC;MAC3C,MAAMyI,IAAI,GAAGjD,YAAY,CAACG,qBAAqB,CAAC,CAAC;MACjD,MAAMoC,YAAY,GAAGjF,SAAS,KAAK,YAAY;;MAE/C;MACA,IAAIY,QAAQ,CAAC2K,GAAG,KAAK,KAAK,IAAItG,YAAY,EAAE;QAC1CoB,QAAQ,GAAG,CAACA,QAAQ;MACtB;MACA,MAAM/K,IAAI,GAAG2J,YAAY,GAAGU,IAAI,CAAC/C,KAAK,GAAG+C,IAAI,CAAChD,MAAM;MACpD,MAAMkB,KAAK,GAAGwC,QAAQ,GAAG/K,IAAI,GAAG,GAAG;;MAEnC;MACA;MACA,MAAMsC,SAAS,GAAGnB,aAAa,CAACC,KAAK,EAAErB,kBAAkB,CAAClC,OAAO,EAAEyD,QAAQ,EAAEC,OAAO,EAAEgH,KAAK,EAAE9G,SAAS,EAAEC,uBAAuB,CAAC7D,OAAO,EAAEqQ,mBAAmB,CAACrQ,OAAO,CAAC;MACrK,MAAMqS,YAAY,GAAG,CAAC7G,QAAQ,CAAC5H,SAAS,EAAEa,SAAS,CAAC;;MAEpD;MACA,IAAIuH,YAAY,CAACzI,KAAK,CAAC,IAAI4I,YAAY,CAAC5I,KAAK,CAAC,EAAE;QAC9C;QACA;QACA;QACA,IAAIqN,YAAY,CAAC5Q,OAAO,IAAI0K,KAAK,EAAE;UACjC,IAAI,CAAC2H,YAAY,EAAE;YACjB;YACA;YACA;;YAEA,IAAIvG,YAAY,EAAE;cAChB8B,oBAAoB,CAACV,QAAQ,GAAG,CAAC,GAAG,gBAAgB,GAAG,gBAAgB,CAAC;YAC1E,CAAC,MAAM;cACLU,oBAAoB,CAACV,QAAQ,GAAG,CAAC,GAAG,cAAc,GAAG,cAAc,CAAC;YACtE;UACF,CAAC,MAAM;YACL;YACAU,oBAAoB,CAAC9B,YAAY,GAAG,YAAY,GAAG,UAAU,CAAC;UAChE;QACF;MACF;MACA,IAAIuG,YAAY,EAAE;QAChB,MAAMzM,4BAA4B,GAAG+K,+BAA+B,CAAC3Q,OAAO;;QAE5E;QACAsJ,QAAQ,CAAC7E,SAAS,CAAC;;QAEnB;QACA;QACAkB,kBAAkB,CAACpB,WAAW,EAAEE,SAAS,EAAEmB,4BAA4B,CAAC;MAC1E;MACAgL,YAAY,CAAC5Q,OAAO,GAAG0K,KAAK;IAC9B,CAAC;IACD,OAAOQ,aAAa;EACtB,CAAC,EAAE,CAACnH,OAAO,CAAC,CAAC;EACb,MAAM/B,eAAe,GAAGjD,WAAW,CAAC4B,EAAE,IAAI;IACxCwP,SAAS,CAAC6B,UAAU,IAAI;MACtB,IAAI,CAACA,UAAU,CAACC,GAAG,CAACtR,EAAE,CAAC,EAAE;QACvB,OAAOqR,UAAU;MACnB;MACA,MAAME,UAAU,GAAG,IAAI9B,GAAG,CAAC4B,UAAU,CAAC;MACtCE,UAAU,CAACI,MAAM,CAAC3R,EAAE,CAAC;MACrB,OAAOuR,UAAU;IACnB,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;EACN,MAAMzQ,aAAa,GAAG1C,WAAW,CAAC4B,EAAE,IAAI;IACtC,MAAM;MACJqD,MAAM;MACNI,KAAK,EAAER;IACT,CAAC,GAAG1B,kBAAkB,CAAClC,OAAO;IAC9B,MAAM+E,KAAK,GAAGf,MAAM,CAACuO,GAAG,CAAC5R,EAAE,CAAC;IAC5B,IAAIoE,KAAK,IAAI,IAAI,EAAE;MACjB;IACF;IACA,MAAM;MACJxE,aAAa;MACbC;IACF,CAAC,GAAGuE,KAAK,CAAC/E,OAAO;IACjB,IAAI,CAACQ,WAAW,EAAE;MAChB;IACF;IACA,MAAM+D,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;IAClD,MAAMa,KAAK,GAAGN,WAAW,CAAC4D,OAAO,CAACpD,KAAK,CAAC;IACxC,IAAIF,KAAK,GAAG,CAAC,EAAE;MACb;IACF;IACA,MAAM2N,WAAW,GAAG5O,SAAS,CAACiB,KAAK,CAAC;IACpC,IAAI2N,WAAW,KAAKjS,aAAa,EAAE;MACjC;MACA;IACF;IACAsD,uBAAuB,CAAC7D,OAAO,CAACqF,GAAG,CAAC1E,EAAE,EAAE6R,WAAW,CAAC;IACpD,MAAM,CAAC/O,QAAQ,EAAEC,OAAO,CAAC,GAAG+C,oBAAoB,CAAC9F,EAAE,EAAE4D,WAAW,CAAC;IACjE,IAAId,QAAQ,IAAI,IAAI,IAAIC,OAAO,IAAI,IAAI,EAAE;MACvC;IACF;IACA,MAAMgD,WAAW,GAAG7B,KAAK,KAAKN,WAAW,CAACmB,MAAM,GAAG,CAAC;IACpD,MAAMgF,KAAK,GAAGhE,WAAW,GAAG8L,WAAW,GAAGjS,aAAa,GAAGiS,WAAW;IACrE,MAAM/N,SAAS,GAAGnB,aAAa,CAAC,IAAI,EAAEpB,kBAAkB,CAAClC,OAAO,EAAEyD,QAAQ,EAAEC,OAAO,EAAEgH,KAAK,EAAE9G,SAAS,EAAEC,uBAAuB,CAAC7D,OAAO,EAAE,IAAI,CAAC;IAC7I,IAAI4D,SAAS,KAAKa,SAAS,EAAE;MAC3B,MAAMmB,4BAA4B,GAAG+K,+BAA+B,CAAC3Q,OAAO;MAC5EsJ,QAAQ,CAAC7E,SAAS,CAAC;;MAEnB;MACA;MACAkB,kBAAkB,CAACpB,WAAW,EAAEE,SAAS,EAAEmB,4BAA4B,CAAC;IAC1E;EACF,CAAC,EAAE,EAAE,CAAC;EACN,MAAMlE,WAAW,GAAG3C,WAAW,CAAC4B,EAAE,IAAI;IACpC,MAAM;MACJqD,MAAM;MACNI,KAAK,EAAER;IACT,CAAC,GAAG1B,kBAAkB,CAAClC,OAAO;IAC9B,MAAM+E,KAAK,GAAGf,MAAM,CAACuO,GAAG,CAAC5R,EAAE,CAAC;IAC5B,IAAIoE,KAAK,IAAI,IAAI,EAAE;MACjB;IACF;IACA,MAAM;MACJxE,aAAa;MACbO;IACF,CAAC,GAAGiE,KAAK,CAAC/E,OAAO;IACjB,MAAMyS,kBAAkB,GAAG5O,uBAAuB,CAAC7D,OAAO,CAACuS,GAAG,CAAC5R,EAAE,CAAC,IAAIG,OAAO;IAC7E,IAAI,CAAC2R,kBAAkB,EAAE;MACvB;IACF;IACA,MAAMlO,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;IAClD,MAAMa,KAAK,GAAGN,WAAW,CAAC4D,OAAO,CAACpD,KAAK,CAAC;IACxC,IAAIF,KAAK,GAAG,CAAC,EAAE;MACb;IACF;IACA,MAAM2N,WAAW,GAAG5O,SAAS,CAACiB,KAAK,CAAC;IACpC,IAAI2N,WAAW,KAAKjS,aAAa,EAAE;MACjC;MACA;IACF;IACA,MAAM,CAACkD,QAAQ,EAAEC,OAAO,CAAC,GAAG+C,oBAAoB,CAAC9F,EAAE,EAAE4D,WAAW,CAAC;IACjE,IAAId,QAAQ,IAAI,IAAI,IAAIC,OAAO,IAAI,IAAI,EAAE;MACvC;IACF;IACA,MAAMgD,WAAW,GAAG7B,KAAK,KAAKN,WAAW,CAACmB,MAAM,GAAG,CAAC;IACpD,MAAMgF,KAAK,GAAGhE,WAAW,GAAGnG,aAAa,GAAGkS,kBAAkB,GAAGA,kBAAkB;IACnF,MAAMhO,SAAS,GAAGnB,aAAa,CAAC,IAAI,EAAEpB,kBAAkB,CAAClC,OAAO,EAAEyD,QAAQ,EAAEC,OAAO,EAAEgH,KAAK,EAAE9G,SAAS,EAAEC,uBAAuB,CAAC7D,OAAO,EAAE,IAAI,CAAC;IAC7I,IAAI4D,SAAS,KAAKa,SAAS,EAAE;MAC3B,MAAMmB,4BAA4B,GAAG+K,+BAA+B,CAAC3Q,OAAO;MAC5EsJ,QAAQ,CAAC7E,SAAS,CAAC;;MAEnB;MACA;MACAkB,kBAAkB,CAACpB,WAAW,EAAEE,SAAS,EAAEmB,4BAA4B,CAAC;IAC1E;EACF,CAAC,EAAE,EAAE,CAAC;EACN,MAAM9D,WAAW,GAAG/C,WAAW,CAAC,CAAC4B,EAAE,EAAEsE,QAAQ,EAAE6L,eAAe,KAAK;IACjE,MAAM;MACJnQ,EAAE,EAAEoD,OAAO;MACXC,MAAM;MACNI,KAAK,EAAER,SAAS;MAChB7B;IACF,CAAC,GAAGG,kBAAkB,CAAClC,OAAO;IAC9B,IAAI,CAAC8Q,eAAe,IAAI/O,KAAK,MAAM,QAAQ,EAAE;MAC3C,MAAMkC,eAAe,GAAGC,2BAA2B,CAACH,OAAO,CAAC;MAC5DkB,QAAQ,GAAGA,QAAQ,GAAGhB,eAAe,GAAG,GAAG;IAC7C;IACA,MAAMc,KAAK,GAAGf,MAAM,CAACuO,GAAG,CAAC5R,EAAE,CAAC;IAC5B,IAAIoE,KAAK,IAAI,IAAI,EAAE;MACjB;IACF;IACA,IAAI;MACFxE,aAAa;MACbC,WAAW;MACXK,OAAO;MACPC;IACF,CAAC,GAAGiE,KAAK,CAAC/E,OAAO;IACjB,IAAI+B,KAAK,KAAK,QAAQ,EAAE;MACtB,MAAMkC,eAAe,GAAGC,2BAA2B,CAACH,OAAO,CAAC;MAC5DjD,OAAO,GAAGA,OAAO,GAAGmD,eAAe,GAAG,GAAG;MACzC,IAAIpD,OAAO,IAAI,IAAI,EAAE;QACnBA,OAAO,GAAGA,OAAO,GAAGoD,eAAe,GAAG,GAAG;MAC3C;IACF;IACA,MAAMM,WAAW,GAAGC,sBAAsB,CAACR,MAAM,CAAC;IAClD,MAAMa,KAAK,GAAGN,WAAW,CAAC4D,OAAO,CAACpD,KAAK,CAAC;IACxC,IAAIF,KAAK,GAAG,CAAC,EAAE;MACb;IACF;IACA,MAAM2N,WAAW,GAAG5O,SAAS,CAACiB,KAAK,CAAC;IACpC,IAAI2N,WAAW,KAAKvN,QAAQ,EAAE;MAC5B;IACF;IACA,IAAIzE,WAAW,IAAIyE,QAAQ,KAAK1E,aAAa,EAAE,CAAC,KAAM;MACpD,MAAMmS,cAAc,GAAGzN,QAAQ;MAC/BA,QAAQ,GAAGE,IAAI,CAACkB,GAAG,CAACxF,OAAO,IAAI,IAAI,GAAGA,OAAO,GAAG,GAAG,EAAEsE,IAAI,CAACmB,GAAG,CAACxF,OAAO,EAAEmE,QAAQ,CAAC,CAAC;MACjF;QACE,IAAIyN,cAAc,KAAKzN,QAAQ,EAAE;UAC/BsB,OAAO,CAACC,KAAK,CAAE,iBAAgBkM,cAAe,0BAAyB3N,KAAK,CAAC/E,OAAO,CAACW,EAAG,8CAA6C,CAAC;QACxI;MACF;IACF;IACA,MAAM,CAAC8C,QAAQ,EAAEC,OAAO,CAAC,GAAG+C,oBAAoB,CAAC9F,EAAE,EAAE4D,WAAW,CAAC;IACjE,IAAId,QAAQ,IAAI,IAAI,IAAIC,OAAO,IAAI,IAAI,EAAE;MACvC;IACF;IACA,MAAMgD,WAAW,GAAG7B,KAAK,KAAKN,WAAW,CAACmB,MAAM,GAAG,CAAC;IACpD,MAAMgF,KAAK,GAAGhE,WAAW,GAAG8L,WAAW,GAAGvN,QAAQ,GAAGA,QAAQ,GAAGuN,WAAW;IAC3E,MAAM/N,SAAS,GAAGnB,aAAa,CAAC,IAAI,EAAEpB,kBAAkB,CAAClC,OAAO,EAAEyD,QAAQ,EAAEC,OAAO,EAAEgH,KAAK,EAAE9G,SAAS,EAAEC,uBAAuB,CAAC7D,OAAO,EAAE,IAAI,CAAC;IAC7I,IAAI4D,SAAS,KAAKa,SAAS,EAAE;MAC3B,MAAMmB,4BAA4B,GAAG+K,+BAA+B,CAAC3Q,OAAO;MAC5EsJ,QAAQ,CAAC7E,SAAS,CAAC;;MAEnB;MACA;MACAkB,kBAAkB,CAACpB,WAAW,EAAEE,SAAS,EAAEmB,4BAA4B,CAAC;IAC1E;EACF,CAAC,EAAE,EAAE,CAAC;EACN,MAAMtE,OAAO,GAAGlC,OAAO,CAAC,OAAO;IAC7B6Q,cAAc;IACdxO,aAAa;IACboF,SAAS;IACTnF,WAAW;IACXC,YAAY;IACZC,aAAa;IACbmC,OAAO;IACPlC,aAAa;IACbsQ,oBAAoB;IACpBrQ,WAAW;IACX6Q,aAAa,EAAEA,CAAChS,EAAE,EAAE4C,KAAK,KAAK;MAC5B2M,iBAAiB,CAACvP,EAAE,CAAC;MACrB,IAAIqL,YAAY,CAACzI,KAAK,CAAC,IAAI4I,YAAY,CAAC5I,KAAK,CAAC,EAAE;QAC9C,MAAM4H,aAAa,GAAGxD,eAAe,CAAChH,EAAE,CAAC;QACzC0P,mBAAmB,CAACrQ,OAAO,GAAG;UAC5B8M,cAAc,EAAE3B,aAAa,CAACzB,qBAAqB,CAAC,CAAC;UACrDmD,UAAU,EAAElB,aAAa,CAACpI,KAAK,EAAE5C,EAAE,EAAEkG,SAAS,CAAC;UAC/CzC,KAAK,EAAElC,kBAAkB,CAAClC,OAAO,CAACoE;QACpC,CAAC;MACH;IACF,CAAC;IACDwO,YAAY,EAAEA,CAAA,KAAM;MAClBnF,sBAAsB,CAAC,CAAC;MACxByC,iBAAiB,CAAC,IAAI,CAAC;MACvBG,mBAAmB,CAACrQ,OAAO,GAAG,IAAI;IACpC,CAAC;IACD+B,KAAK;IACLC;EACF,CAAC,CAAC,EAAE,CAACiO,cAAc,EAAExO,aAAa,EAAEoF,SAAS,EAAEnF,WAAW,EAAEC,YAAY,EAAEC,aAAa,EAAEmC,OAAO,EAAElC,aAAa,EAAEsQ,oBAAoB,EAAErQ,WAAW,EAAEC,KAAK,EAAEC,eAAe,CAAC,CAAC;EAC5K,MAAMd,KAAK,GAAG;IACZ2R,OAAO,EAAE,MAAM;IACfC,aAAa,EAAEjM,SAAS,KAAK,YAAY,GAAG,KAAK,GAAG,QAAQ;IAC5D2C,MAAM,EAAE,MAAM;IACdsI,QAAQ,EAAE,QAAQ;IAClBrI,KAAK,EAAE;EACT,CAAC;EACD,OAAO7K,aAAa,CAACqB,iBAAiB,CAAC8S,QAAQ,EAAE;IAC/C3S,QAAQ,EAAExB,aAAa,CAACyC,IAAI,EAAE;MAC5BjB,QAAQ;MACRC,SAAS,EAAEC,kBAAkB;MAC7B,kBAAkB,EAAE,EAAE;MACtB,4BAA4B,EAAEuG,SAAS;MACvC,qBAAqB,EAAE9C,OAAO;MAC9B,wBAAwB,EAAEhC,KAAK;MAC/Bb,KAAK,EAAE;QACL,GAAGA,KAAK;QACR,GAAGC;MACL;IACF,CAAC,CAAC;IACFyO,KAAK,EAAEtO;EACT,CAAC,CAAC;AACJ;AACA,MAAM0R,UAAU,GAAGlU,UAAU,CAAC,CAACqE,KAAK,EAAEC,GAAG,KAAKxE,aAAa,CAACkR,0BAA0B,EAAE;EACtF,GAAG3M,KAAK;EACRzC,YAAY,EAAE0C;AAChB,CAAC,CAAC,CAAC;AACH0M,0BAA0B,CAAC5P,WAAW,GAAG,YAAY;AACrD8S,UAAU,CAAC9S,WAAW,GAAG,wBAAwB;AAEjD,SAAS+S,iBAAiBA,CAAC;EACzB7S,QAAQ,GAAG,IAAI;EACfC,SAAS,EAAEC,kBAAkB,GAAG,EAAE;EAClC2K,QAAQ,GAAG,KAAK;EAChBtK,EAAE,EAAEC,WAAW,GAAG,IAAI;EACtBsS,UAAU;EACVhS,KAAK,EAAEC,cAAc,GAAG,CAAC,CAAC;EAC1BC,OAAO,EAAEC,IAAI,GAAG;AAClB,CAAC,EAAE;EACD,MAAM8R,aAAa,GAAG9T,MAAM,CAAC,IAAI,CAAC;;EAElC;EACA,MAAM4C,YAAY,GAAG5C,MAAM,CAAC;IAC1B6T;EACF,CAAC,CAAC;EACFjU,SAAS,CAAC,MAAM;IACdgD,YAAY,CAACjC,OAAO,CAACkT,UAAU,GAAGA,UAAU;EAC9C,CAAC,CAAC;EACF,MAAME,iBAAiB,GAAGpU,UAAU,CAACiB,iBAAiB,CAAC;EACvD,IAAImT,iBAAiB,KAAK,IAAI,EAAE;IAC9B,MAAM7R,KAAK,CAAE,6EAA4E,CAAC;EAC5F;EACA,MAAM;IACJ0O,cAAc;IACdpJ,SAAS;IACT9C,OAAO;IACPoO,oBAAoB;IACpBQ,aAAa;IACbC;EACF,CAAC,GAAGQ,iBAAiB;EACrB,MAAMC,cAAc,GAAGzT,WAAW,CAACgB,WAAW,CAAC;EAC/C,MAAM0S,UAAU,GAAGrD,cAAc,KAAKoD,cAAc;EACpD,MAAM,CAACE,SAAS,EAAEC,YAAY,CAAC,GAAGlU,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAAC4L,aAAa,EAAEuI,gBAAgB,CAAC,GAAGnU,QAAQ,CAAC,IAAI,CAAC;EACxD,MAAMoU,mBAAmB,GAAG3U,WAAW,CAAC,MAAM;IAC5C;IACA;IACA,MAAM4U,GAAG,GAAGR,aAAa,CAACnT,OAAO;IACjC2T,GAAG,CAACC,IAAI,CAAC,CAAC;IACVhB,YAAY,CAAC,CAAC;IACd,MAAM;MACJM;IACF,CAAC,GAAGjR,YAAY,CAACjC,OAAO;IACxB,IAAIkT,UAAU,EAAE;MACdA,UAAU,CAAC,KAAK,CAAC;IACnB;EACF,CAAC,EAAE,CAACN,YAAY,CAAC,CAAC;EAClB3T,SAAS,CAAC,MAAM;IACd,IAAIgM,QAAQ,EAAE;MACZwI,gBAAgB,CAAC,IAAI,CAAC;IACxB,CAAC,MAAM;MACL,MAAMvI,aAAa,GAAGiH,oBAAoB,CAACkB,cAAc,CAAC;MAC1DI,gBAAgB,CAAC,MAAMvI,aAAa,CAAC;IACvC;EACF,CAAC,EAAE,CAACD,QAAQ,EAAEoI,cAAc,EAAElB,oBAAoB,CAAC,CAAC;EACpDlT,SAAS,CAAC,MAAM;IACd,IAAIgM,QAAQ,IAAIC,aAAa,IAAI,IAAI,IAAI,CAACoI,UAAU,EAAE;MACpD;IACF;IACA,MAAMO,MAAM,GAAGtQ,KAAK,IAAI;MACtB2H,aAAa,CAAC3H,KAAK,CAAC;IACtB,CAAC;IACD,MAAMuQ,YAAY,GAAGvQ,KAAK,IAAI;MAC5B2H,aAAa,CAAC3H,KAAK,CAAC;IACtB,CAAC;IACD,MAAMwQ,UAAU,GAAGZ,aAAa,CAACnT,OAAO;IACxC,MAAMgU,cAAc,GAAGD,UAAU,CAACE,aAAa;IAC/CD,cAAc,CAACE,IAAI,CAACvJ,gBAAgB,CAAC,aAAa,EAAE+I,mBAAmB,CAAC;IACxEM,cAAc,CAACE,IAAI,CAACvJ,gBAAgB,CAAC,WAAW,EAAEkJ,MAAM,CAAC;IACzDG,cAAc,CAACE,IAAI,CAACvJ,gBAAgB,CAAC,WAAW,EAAEkJ,MAAM,CAAC;IACzDG,cAAc,CAACE,IAAI,CAACvJ,gBAAgB,CAAC,YAAY,EAAEmJ,YAAY,CAAC;IAChEK,MAAM,CAACxJ,gBAAgB,CAAC,SAAS,EAAE+I,mBAAmB,CAAC;IACvDS,MAAM,CAACxJ,gBAAgB,CAAC,UAAU,EAAE+I,mBAAmB,CAAC;IACxD,OAAO,MAAM;MACXM,cAAc,CAACE,IAAI,CAACpJ,mBAAmB,CAAC,aAAa,EAAE4I,mBAAmB,CAAC;MAC3EM,cAAc,CAACE,IAAI,CAACpJ,mBAAmB,CAAC,WAAW,EAAE+I,MAAM,CAAC;MAC5DG,cAAc,CAACE,IAAI,CAACpJ,mBAAmB,CAAC,WAAW,EAAE+I,MAAM,CAAC;MAC5DG,cAAc,CAACE,IAAI,CAACpJ,mBAAmB,CAAC,YAAY,EAAEgJ,YAAY,CAAC;MACnEK,MAAM,CAACrJ,mBAAmB,CAAC,SAAS,EAAE4I,mBAAmB,CAAC;MAC1DS,MAAM,CAACrJ,mBAAmB,CAAC,UAAU,EAAE4I,mBAAmB,CAAC;IAC7D,CAAC;EACH,CAAC,EAAE,CAAC7M,SAAS,EAAEoE,QAAQ,EAAEqI,UAAU,EAAEpI,aAAa,EAAEwI,mBAAmB,CAAC,CAAC;EACzE1I,sCAAsC,CAAC;IACrCC,QAAQ;IACR/C,QAAQ,EAAEmL,cAAc;IACxBnI;EACF,CAAC,CAAC;EACF,MAAMhK,KAAK,GAAG;IACZkT,MAAM,EAAE7G,cAAc,CAAC1G,SAAS,CAAC;IACjCwN,WAAW,EAAE,MAAM;IACnBC,UAAU,EAAE;EACd,CAAC;EACD,OAAO1V,aAAa,CAACyC,IAAI,EAAE;IACzBjB,QAAQ;IACRC,SAAS,EAAEC,kBAAkB;IAC7B,2BAA2B,EAAEgT,UAAU,GAAG,SAAS,GAAGC,SAAS,GAAG,UAAU,GAAGzQ,SAAS;IACxF,4BAA4B,EAAE+D,SAAS;IACvC,qBAAqB,EAAE9C,OAAO;IAC9B,kCAAkC,EAAE,CAACkH,QAAQ;IAC7C,6BAA6B,EAAEoI,cAAc;IAC7CkB,MAAM,EAAEA,CAAA,KAAMf,YAAY,CAAC,KAAK,CAAC;IACjCgB,OAAO,EAAEA,CAAA,KAAMhB,YAAY,CAAC,IAAI,CAAC;IACjCiB,WAAW,EAAElR,KAAK,IAAI;MACpBoP,aAAa,CAACU,cAAc,EAAE9P,KAAK,CAACmR,WAAW,CAAC;MAChD,MAAM;QACJxB;MACF,CAAC,GAAGjR,YAAY,CAACjC,OAAO;MACxB,IAAIkT,UAAU,EAAE;QACdA,UAAU,CAAC,IAAI,CAAC;MAClB;IACF,CAAC;IACDyB,SAAS,EAAEjB,mBAAmB;IAC9BkB,aAAa,EAAElB,mBAAmB;IAClCmB,UAAU,EAAEnB,mBAAmB;IAC/BoB,YAAY,EAAEvR,KAAK,IAAI;MACrBoP,aAAa,CAACU,cAAc,EAAE9P,KAAK,CAACmR,WAAW,CAAC;MAChD,MAAM;QACJxB;MACF,CAAC,GAAGjR,YAAY,CAACjC,OAAO;MACxB,IAAIkT,UAAU,EAAE;QACdA,UAAU,CAAC,IAAI,CAAC;MAClB;IACF,CAAC;IACD9P,GAAG,EAAE+P,aAAa;IAClB4B,IAAI,EAAE,WAAW;IACjB7T,KAAK,EAAE;MACL,GAAGA,KAAK;MACR,GAAGC;IACL,CAAC;IACD6T,QAAQ,EAAE;EACZ,CAAC,CAAC;AACJ;AACA/B,iBAAiB,CAAC/S,WAAW,GAAG,mBAAmB;AAEnD,SAASgD,KAAK,EAAE8P,UAAU,EAAEC,iBAAiB,EAAE/O,2BAA2B"},"metadata":{},"sourceType":"module","externalDependencies":[]}